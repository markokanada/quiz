# Csoportmunka-eszközök tesztkérdések (Trello és társai)

## 1. Mi a Trello fő feladata?
- [ ] A) Dokumentumok tárolása
- [ ] B) Projektmenedzsment és feladatkövetés
- [ ] C) Videóhívások lebonyolítása
- [ ] D) Közösségi média kezelése

<details>
<summary>Megoldás</summary>

**B) Projektmenedzsment és feladatkövetés**

A Trello egy kanban-alapú projektmenedzsment eszköz, ahol feladatkártyákkal, listákkal és táblákkal lehet nyomon követni a munkafolyamatokat.
</details>

## 2. Melyik NEM a Trello alapvető eleme?
- [ ] A) Kártyák (Cards)
- [ ] B) Listák (Lists)
- [ ] C) Táblák (Boards)
- [ ] D) Következtetéses algoritmus (AI)

<details>
<summary>Megoldás</summary>

**D) Következtetéses algoritmus (AI)**

A Trello nem tartalmaz beépített AI-alapú következtetési rendszert, hanem manuális feladatkezelésre épül.
</details>

## 3. Mire használható egy Trello "kártya"?
- [ ] A) Csak szöveges jegyzetek írására
- [ ] B) Feladatok, határidők, fájlok és kommentek hozzárendelésére
- [ ] C) Kizárólag képek megosztására
- [ ] D) Csak külső alkalmazások integrálására

<details>
<summary>Megoldás</summary>

**B) Feladatok, határidők, fájlok és kommentek hozzárendelésére**

A kártyákba lehet feladatleírást, határidőt, csatolmányt, címkét és kommenteket helyezni.
</details>

## 4. Melyik funkció segít a Trello-ban a feladatok határidőinek nyomon követésében?
- [ ] A) Power-Ups
- [ ] B) Címkék (Labels)
- [ ] C) Határidő-beállítás (Due Date)
- [ ] D) Háttérképek

<details>
<summary>Megoldás</summary>

**C) Határidő-beállítás (Due Date)**

A "Due Date" lehetővé teszi, hogy határidőt rendeljünk egy feladathoz, és emlékeztetőket kapjunk.
</details>

## 5. Mi szükséges egy Trello tábla megosztásához csapattagokkal?
- [ ] A) Mindenkinek prémium felhasználónak kell lennie
- [ ] B) Elég egy meghívó elküldése az e-mail címükre
- [ ] C) Csak közösségi média felhasználókkal lehet megosztani
- [ ] D) A táblákat nem lehet megosztani

<details>
<summary>Megoldás</summary>

**B) Elég egy meghívó elküldése az e-mail címükre**

A táblákat egyszerűen meg lehet osztani meghívóval, ingyenes fiókkal is.
</details>

## 6. Melyik NEM igaz a Trello-ról?
- [ ] A) Ingyenes verziója korlátlan táblákat kínál
- [ ] B) Több platformon is elérhető (web, mobil)
- [ ] C) Integrálható más alkalmazásokkal (pl. Slack, Google Drive)
- [ ] D) Használható Scrum és Kanban módszertanhoz

<details>
<summary>Megoldás</summary>

**A) Ingyenes verziója korlátlan táblákat kínál**

Az ingyenes verzió korlátozott számú Power-Upot és csapatméretet támogat, de a táblák száma valóban korlátlan.
</details>

## 7. Mi a "Kanban" módszer?
- [ ] A) Egy közösségi média platform
- [ ] B) Egy projektmenedzsment rendszer, ahol feladatokat oszlopok között mozgatnak
- [ ] C) Egy programozási nyelv
- [ ] D) Egy videókonferencia-eszköz

<details>
<summary>Megoldás</summary>

**B) Egy projektmenedzsment rendszer, ahol feladatokat oszlopok között mozgatnak**

A Kanban a Trello alapja, ahol a feladatokat "Todo", "In Progress", "Done" stb. oszlopokba rendezik.
</details>

## 8. Mire valók a Trello "címkék" (Labels)?
- [ ] A) Kizárólag színes díszítésre
- [ ] B) Feladatok kategorizálására és szűrésére
- [ ] C) Csak prémium felhasználók számára
- [ ] D) Kizárólag külső integrációkhoz

<details>
<summary>Megoldás</summary>

**B) Feladatok kategorizálására és szűrésére**

A címkék segítenek a feladatok tematikus csoportosításában (pl. "Fontos", "Hibajavítás").
</details>

## 9. Melyik eszköz hasonlít leginkább a Trello-ra?
- [ ] A) Facebook
- [ ] B) Asana
- [ ] C) Photoshop
- [ ] D) Zoom

<details>
<summary>Megoldás</summary>

**B) Asana**

Az Asana szintén projektmenedzsment eszköz, hasonló feladatkövetési lehetőségekkel.
</details>

## 10. Mi a "Power-Up" a Trello-ban?
- [ ] A) Egy fizetési mód
- [ ] B) Kiegészítő, ami új funkciókat ad (pl. naptár, Slack integráció)
- [ ] C) Egy játék
- [ ] D) Csak adminok számára elérhető beállítás

<details>
<summary>Megoldás</summary>

**B) Kiegészítő, ami új funkciókat ad (pl. naptár, Slack integráció)**

Power-Upokkal lehet például Google Drive-ot kapcsolni vagy időmérést használni.
</details>

## 11. Mi az előnye a digitális csoportmunka-eszközöknek?
- [ ] A) Csak a vezetőknek hasznos
- [ ] B) Növeli az átláthatóságot és a hatékonyságot
- [ ] C) Kizárólag otthoni használatra való
- [ ] D) Megnehezíti a kommunikációt

<details>
<summary>Megoldás</summary>

**B) Növeli az átláthatóságot és a hatékonyságot**

Az eszközök (pl. Trello) segítenek a feladatok nyomon követésében és a csapat koordinálásában.
</details>

## 12. Mi lehet a hátránya a túl sok csoportmunka-eszköz használatának?
- [ ] A) Az információ szétszóródik, nehezebb a nyomon követés
- [ ] B) Több fizetős előfizetés kell
- [ ] C) Csak egy eszköz használható egyszerre
- [ ] D) Nincs hátránya

<details>
<summary>Megoldás</summary>

**A) Az információ szétszóródik, nehezebb a nyomon követés**

Több platform használata összezavarhatja a csapatot, ha nincs egységes rendszer.
</details>

## 13. Melyik NEM jellemző egy jó csoportmunka-eszközre?
- [ ] A) Felhasználóbarát felület
- [ ] B) Rugalmas testreszabhatóság
- [ ] C) Csak offline működés
- [ ] D) Integráció más alkalmazásokkal

<details>
<summary>Megoldás</summary>

**C) Csak offline működés**

A modern eszközök (pl. Trello) felhőalapúak, így online együttműködést tesznek lehetővé.
</details>

## 14. Miért fontos a valós idejű együttműködés egy csoportmunka-eszközben?
- [ ] A) Mert mindenki ugyanazon az eszközön dolgozik
- [ ] B) Mert csökkenti a kommunikációs késedelmet és hibákat
- [ ] C) Mert kötelező a vállalati szabályzat szerint
- [ ] D) Mert így mindenki látja a többiek jelszavát

<details>
<summary>Megoldás</summary>

**B) Mert csökkenti a kommunikációs késedelmet és hibákat**

A valós idejű frissítések (pl. Trello vagy Slack) gyorsabb reakciót és pontosabb munkát tesznek lehetővé.
</details>

## 15. Melyik funkció hiányzik a Trello ingyenes verziójából?
- [ ] A) Alapvető kártyalétrehozás
- [ ] B) Táblák megosztása
- [ ] C) Korlátlan Power-Upok
- [ ] D) Mobilalkalmazás

<details>
<summary>Megoldás</summary>

**C) Korlátlan Power-Upok**

Az ingyenes verzióban csak 1 Power-Up használható táblánként.
</details>

## 16. Mi a Scrum?
- [ ] A) Egy sportág
- [ ] B) Egy agilis projektmenedzsment módszer
- [ ] C) Egy programozási nyelv
- [ ] D) Egy Trello alternatíva

<details>
<summary>Megoldás</summary>

**B) Egy agilis projektmenedzsment módszer**

A Scrum egy iteratív fejlesztési módszer, ami sprintekre osztja a feladatokat (pl. Jira használja).
</details>

## 17. Mi a legnagyobb kihívás a csoportmunka során?
- [ ] A) Mindenki ugyanolyan gyorsan dolgozik
- [ ] B) A kommunikáció és koordináció hiánya
- [ ] C) A túl sok szabadidő
- [ ] D) A túl kevés digitális eszköz

<details>
<summary>Megoldás</summary>

**B) A kommunikáció és koordináció hiánya**

A hatékony kommunikáció és feladatelosztás nélkül káosz keletkezhet.
</details>

## 18. Melyik igaz a Trello prémium verziójára?
- [ ] A) Korlátlan Power-Upok és speciális sablonok
- [ ] B) Csak egy tábla használható
- [ ] C) Nem lehet megosztani másokkal
- [ ] D) Nincs mobilalkalmazás

<details>
<summary>Megoldás</summary>

**A) Korlátlan Power-Upok és speciális sablonok**

A prémium (Business Class) verzióban több Power-Up és haladó funkció érhető el.
</details>

## 19. Mi a "Checklist" funkció a Trello-ban?
- [ ] A) Egy bevásárlólista
- [ ] B) Részfeladatok létrehozása egy kártyán belül
- [ ] C) Egy játék
- [ ] D) Csak külső alkalmazásokhoz való

<details>
<summary>Megoldás</summary>

**B) Részfeladatok létrehozása egy kártyán belül**

A checklist segítségével egy feladaton belül több lépést is lehet követni.
</details>

## 20. Mi az előnye a felhőalapú csoportmunka-eszközöknek?
- [ ] A) Csak egy számítógépről elérhetők
- [ ] B) Bárhonnan és bármikor hozzáférhetőek a friss adatok
- [ ] C) Nincs autómentes funkciójuk
- [ ] D) Csak egy felhasználó dolgozhat rajta

<details>
<summary>Megoldás</summary>

**B) Bárhonnan és bármikor hozzáférhetőek a friss adatok**

A felhőalapú tárolás lehetővé teszi, hogy a csapat bárhol szinkronizáltan dolgozzon.
</details>

# Git Parancsok Tesztkérdései

## 1. Mire szolgál a `git init` parancs?
- [ ] A) Távoli repository klónozására
- [ ] B) Új lokális Git repository létrehozására 
- [ ] C) Commitok visszavonására
- [ ] D) Fájlok törlésére

<details>
<summary>Megoldás</summary>

**B) Új lokális Git repository létrehozására**

A `git init` inicializál egy üres Git repository-t az aktuális könyvtárban, létrehozva a rejtett .git mappát.
</details>

## 2. Melyik parancs szinkronizálja a lokális változtatásokat a távoli repository-val?
- [ ] A) `git merge`
- [ ] B) `git push` 
- [ ] C) `git stash`
- [ ] D) `git rebase`

<details>
<summary>Megoldás</summary>

**B) `git push`**

A `git push` feltölti a lokális commitokat a távoli repository-ba (pl. GitHub-ra).
</details>

## 3. Hogyan lehet a legutóbbi commit üzenetét módosítani?
- [ ] A) `git commit --amend` 
- [ ] B) `git edit last`
- [ ] C) `git change commit`
- [ ] D) `git reword`

<details>
<summary>Megoldás</summary>

**A) `git commit --amend`**

Ez a parancs megnyitja a szerkesztőt az utolsó commit üzenetének módosításához.
</details>

## 4. Mire való a `git clone` parancs?
- [ ] A) Egy branch másolására
- [ ] B) Egy teljes repository másolására lokális gépre 
- [ ] C) Commitok klónozására
- [ ] D) Git konfiguráció másolására

<details>
<summary>Megoldás</summary>

**B) Egy teljes repository másolására lokális gépre**

Pl.: `git clone https://github.com/felhasznalo/repo.git`
</details>

## 5. Melyik parancs mutatja a változtatásokat a staging area és a munkakönyvtár között?
- [ ] A) `git status`
- [ ] B) `git log`
- [ ] C) `git diff --staged` 
- [ ] D) `git show`

<details>
<summary>Megoldás</summary>

**C) `git diff --staged`**

A staging area (index) és a munkakönyvtár közötti különbségeket jeleníti meg.
</details>

## 6. Hogyan lehet elvetni a munkakönyvtár változtatásait egy fájlban?
- [ ] A) `git undo file.txt`
- [ ] B) `git reset file.txt`
- [ ] C) `git checkout -- file.txt` 
- [ ] D) `git remove file.txt`

<details>
<summary>Megoldás</summary>

**C) `git checkout -- file.txt`**

Visszaállítja a fájlt az utolsó commitolt állapotára.
</details>

## 7. Melyik parancs listázza ki a lokális branch-eket?
- [ ] A) `git branches`
- [ ] B) `git list`
- [ ] C) `git branch` 
- [ ] D) `git show branches`

<details>
<summary>Megoldás</summary>

**C) `git branch`**

A `-a` kapcsolóval a távoli branch-ek is megjelennek.
</details>

## 8. Mire szolgál a `git fetch` parancs?
- [ ] A) Letölti a távoli változtatásokat, de nem egyesíti 
- [ ] B) Törli a lokális változtatásokat
- [ ] C) Feltölti az összes commitot
- [ ] D) Létrehoz egy új branchet

<details>
<summary>Megoldás</summary>

**A) Letölti a távoli változtatásokat, de nem egyesíti**

A `git pull` ezzel szemben letölti ÉS egyesíti a változtatásokat.
</details>

## 9. Hogyan lehet átváltani egy másik branch-re?
- [ ] A) `git switch branch-name` 
- [ ] B) `git change branch-name`
- [ ] C) `git move branch-name`
- [ ] D) `git select branch-name`

<details>
<summary>Megoldás</summary>

**A) `git switch branch-name`**

Alternatíva: `git checkout branch-name` (a régebbi verziókban)
</details>

## 10. Melyik parancs egyesít két branch-et?
- [ ] A) `git combine`
- [ ] B) `git merge` 
- [ ] C) `git unify`
- [ ] D) `git join`

<details>
<summary>Megoldás</summary>

**B) `git merge`**

Pl.: `git merge feature-branch` a feature branch változatait egyesíti az aktuális branch-be.
</details>

## 11. Mire való a `git rebase` parancs?
- [ ] A) Commitok átrendezésére és branch történelem átírására 
- [ ] B) Repository méretének csökkentésére
- [ ] C) Git verzió frissítésére
- [ ] D) Távoli repository törlésére

<details>
<summary>Megoldás</summary>

**A) Commitok átrendezésére és branch történelem átírására**

Alternatíva a merge-nek, de megváltoztatja a commit history-t.
</details>

## 12. Hogyan lehet eltávolítani egy fájlt a Git nyomonkövetéséből?
- [ ] A) `git delete file.txt`
- [ ] B) `git remove file.txt`
- [ ] C) `git rm file.txt` 
- [ ] D) `git exclude file.txt`

<details>
<summary>Megoldás</summary>

**C) `git rm file.txt`**

A fájlt törli a munkakönyvtárból és a staging area-ból is.
</details>

## 13. Melyik parancs mutatja a commit history-t?
- [ ] A) `git history`
- [ ] B) `git log` 
- [ ] C) `git commits`
- [ ] D) `git show-history`

<details>
<summary>Megoldás</summary>

**B) `git log`**

A `--oneline` kapcsolóval tömörebb formátumban jeleníti meg.
</details>

## 14. Hogyan lehet ideiglenesen elmenteni a változtatásokat commit nélkül?
- [ ] A) `git save`
- [ ] B) `git hold`
- [ ] C) `git stash` 
- [ ] D) `git pause`

<details>
<summary>Megoldás</summary>

**C) `git stash`**

Később a `git stash pop` paranccsal lehet visszaállítani.
</details>

## 15. Melyik parancs állít vissza egy fájlt a staging area-ból?
- [ ] A) `git unstage file.txt`
- [ ] B) `git reset HEAD file.txt` 
- [ ] C) `git revert file.txt`
- [ ] D) `git undo file.txt`

<details>
<summary>Megoldás</summary>

**B) `git reset HEAD file.txt`**

Eltávolítja a fájlt a staging area-ból, de megtartja a munkakönyvtárban.
</details>

## 16. Melyik parancs hoz létre új branchet és vált is rá?
- [ ] A) `git branch -b new-branch`
- [ ] B) `git switch -c new-branch` 
- [ ] C) `git new-branch new-branch`
- [ ] D) `git create new-branch`

<details>
<summary>Megoldás</summary>

**B) `git switch -c new-branch`**

A `-c` kapcsoló jelentése: create (létrehozás).
</details>

## 17. Melyik parancs szolgál a konfigurációs beállítások megjelenítésére?
- [ ] A) `git settings`
- [ ] B) `git config --list` 
- [ ] C) `git show-config`
- [ ] D) `git options`

<details>
<summary>Megoldás</summary>

**B) `git config --list`**

Pl. felhasználónév/email beállítása: `git config user.name "Nev"`
</details>

## 18. Hogyan lehet egy távoli repository-t lokálisan hozzáadni?
- [ ] A) `git add origin https://github.com/user/repo.git`
- [ ] B) `git remote add origin https://github.com/user/repo.git` 
- [ ] C) `git connect origin https://github.com/user/repo.git`
- [ ] D) `git link origin https://github.com/user/repo.git`

<details>
<summary>Megoldás</summary>

**B) `git remote add origin https://github.com/user/repo.git`**

Az "origin" a távoli repository alias neve.
</details>

## 19. Melyik parancs töröl egy lokális branch-et?
- [ ] A) `git branch -d branch-name` 
- [ ] B) `git delete branch-name`
- [ ] C) `git remove branch-name`
- [ ] D) `git drop branch-name`

<details>
<summary>Megoldás</summary>

**A) `git branch -d branch-name`**

A `-D` kapcsoló erőltetett törlésre használható.
</details>

## 20. Melyik parancs jeleníti meg a változtatásokat egy adott commitban?
- [ ] A) `git display commit-hash`
- [ ] B) `git changes commit-hash`
- [ ] C) `git show commit-hash` 
- [ ] D) `git view commit-hash`

<details>
<summary>Megoldás</summary>

**C) `git show commit-hash`**

Megmutatja a commit adatait és a benne történt változtatásokat.
</details>

# HTML és CSS Tesztkérdések

## HTML Kérdések

## 1. Mi a HTML alapvető szerkezete?
- [ ] A) `<html><head></head><footer></footer></html>`
- [ ] B) `<html><head></head><body></body></html>`
- [ ] C) `<html><header></header><main></main></html>`
- [ ] D) `<html><title></title><content></content></html>`

<details>
<summary>Megoldás</summary>

**B) `<html><head></head><body></body></html>`**

A HTML alapvető szerkezete tartalmazza a `<html>`, `<head>` és `<body>` elemeket. A `<head>` rész tartalmazza a metaadatokat, míg a `<body>` rész a látható tartalmat.
</details>

## 2. Melyik elem használható hiperhivatkozás létrehozására?
- [ ] A) `<link>`
- [ ] B) `<a>`
- [ ] C) `<href>`
- [ ] D) `<url>`

<details>
<summary>Megoldás</summary>

**B) `<a>`**

A `<a>` (anchor) elem a hiperhivatkozások létrehozására szolgál, a `href` attribútummal megadva a cél URL-t.
</details>

## 3. Mire való a `<div>` elem?
- [ ] A) Képek megjelenítésére
- [ ] B) Táblázatok létrehozására
- [ ] C) Tartalom csoportosítására és stílusozásra
- [ ] D) Űrlapok létrehozására

<details>
<summary>Megoldás</summary>

**C) Tartalom csoportosítására és stílusozásra**

A `<div>` elem egy blokk szintű konténer, amely segít a tartalom csoportosításában és stílusozásában.
</details>

## 4. Hogyan lehet egy képet beszúrni HTML-be?
- [ ] A) `<img src="kep.jpg" alt="Kép leírása">`
- [ ] B) `<image src="kep.jpg" alt="Kép leírása">`
- [ ] C) `<picture src="kep.jpg" alt="Kép leírása">`
- [ ] D) `<photo src="kep.jpg" alt="Kép leírása">`

<details>
<summary>Megoldás</summary>

**A) `<img src="kep.jpg" alt="Kép leírása">`**

A `<img>` elem a képek beszúrására szolgál, ahol a `src` attribútum határozza meg a kép elérési útját, az `alt` pedig a helyettesítő szöveget.
</details>

## 5. Melyik elem jelöl egy rendezetlen listát?
- [ ] A) `<ol>`
- [ ] B) `<ul>`
- [ ] C) `<li>`
- [ ] D) `<list>`

<details>
<summary>Megoldás</summary>

**B) `<ul>`**

A `<ul>` elem rendezetlen listát hoz létre, míg a `<ol>` rendezett listát. A lista elemeit a `<li>` elem jelöli.
</details>

## 6. Mire való a `<span>` elem?
- [ ] A) Blokk szintű tartalom csoportosítására
- [ ] B) Soron belüli tartalom stílusozására
- [ ] C) Táblázatok létrehozására
- [ ] D) Űrlapok létrehozására

<details>
<summary>Megoldás</summary>

**B) Soron belüli tartalom stílusozására**

A `<span>` elem egy soron belüli (inline) konténer, amely segít a tartalom stílusozásában vagy csoportosításában.
</details>

## 7. Melyik elem használható egy űrlap létrehozására?
- [ ] A) `<input>`
- [ ] B) `<form>`
- [ ] C) `<button>`
- [ ] D) `<fieldset>`

<details>
<summary>Megoldás</summary>

**B) `<form>`**

A `<form>` elem egy űrlapot hoz létre, amelyben `<input>`, `<button>` és más elemek helyezhetők el.
</details>

## 8. Melyik attribútum határozza meg a CSS stíluslapot egy HTML oldalon?
- [ ] A) `<style>`
- [ ] B) `<link rel="stylesheet" href="stilus.css">`
- [ ] C) `<css src="stilus.css">`
- [ ] D) `<script src="stilus.css">`

<details>
<summary>Megoldás</summary>

**B) `<link rel="stylesheet" href="stilus.css">`**

A `<link>` elem a `rel="stylesheet"` attribútummal és a `href` segítségével csatol külső CSS fájlokat.
</details>

## 9. Melyik elem jelöl egy táblázat sort?
- [ ] A) `<td>`
- [ ] B) `<tr>`
- [ ] C) `<th>`
- [ ] D) `<table>`

<details>
<summary>Megoldás</summary>

**B) `<tr>`**

A `<tr>` (table row) elem egy táblázat sort jelöl. A `<td>` a cellákat, a `<th>` a fejléc cellákat, a `<table>` pedig magát a táblázatot.
</details>

## 10. Mire való a `alt` attribútum a `<img>` elemben?
- [ ] A) A kép szélességének megadására
- [ ] B) A kép helyettesítő szövegének megadására
- [ ] C) A kép stílusozására
- [ ] D) A kép forrásának megadására

<details>
<summary>Megoldás</summary>

**B) A kép helyettesítő szövegének megadására**

Az `alt` attribútum alternatív szöveget biztosít a képnek, ha az nem tölthető be, vagy a képernyőolvasók számára.
</details>

## CSS Kérdések

## 1. Hogyan lehet egy elem háttérszínét beállítani CSS-ben?
- [ ] A) `background-color: red;`
- [ ] B) `color: red;`
- [ ] C) `bgcolor: red;`
- [ ] D) `background: red;`

<details>
<summary>Megoldás</summary>

**A) `background-color: red;`**

A `background-color` tulajdonság állítja be egy elem háttérszínét.
</details>

## 2. Melyik szabály állítja be a szöveg színét pirosra?
- [ ] A) `text-color: red;`
- [ ] B) `font-color: red;`
- [ ] C) `color: red;`
- [ ] D) `text: red;`

<details>
<summary>Megoldás</summary>

**C) `color: red;`**

A `color` tulajdonság határozza meg a szöveg színét.
</details>

## 3. Melyik egység használható relatív méret megadására?
- [ ] A) `px`
- [ ] B) `em`
- [ ] C) `cm`
- [ ] D) `pt`

<details>
<summary>Megoldás</summary>

**B) `em`**

Az `em` egy relatív egység, amely a szülő elem betűméretéhez viszonyít. A `px` (pixel), `cm` (centiméter) és `pt` (pont) abszolút egységek.
</details>

## 4. Hogyan lehet egy elemet középre igazítani vízszintesen?
- [ ] A) `align: center;`
- [ ] B) `text-align: center;`
- [ ] C) `margin: 0 auto;`
- [ ] D) `position: center;`

<details>
<summary>Megoldás</summary>

**C) `margin: 0 auto;`**

A `margin: 0 auto;` középre igazít egy blokk szintű elemet vízszintesen, feltéve, hogy van megadva szélesség.
</details>

## 5. Melyik tulajdonság szabályozza az elemek megjelenítési típusát?
- [ ] A) `visibility`
- [ ] B) `position`
- [ ] C) `display`
- [ ] D) `float`

<details>
<summary>Megoldás</summary>

**C) `display`**

A `display` tulajdonság határozza meg, hogy egy elem blokk, inline vagy más típusúként jelenjen meg (pl. `block`, `inline`, `flex`).
</details>

## 6. Melyik szabály teszi a szöveg félkövérré?
- [ ] A) `font-style: bold;`
- [ ] B) `font-weight: bold;`
- [ ] C) `text-weight: bold;`
- [ ] D) `bold: true;`

<details>
<summary>Megoldás</summary>

**B) `font-weight: bold;`**

A `font-weight: bold;` állítja be a szöveg félkövér megjelenítését.
</details>

## 7. Hogyan lehet egy elem szélességét 100%-ra állítani?
- [ ] A) `width: 100;`
- [ ] B) `width: 100%;`
- [ ] C) `size: 100%;`
- [ ] D) `full-width: true;`

<details>
<summary>Megoldás</summary>

**B) `width: 100%;`**

A `width: 100%;` az elem szélességét a szülő elem szélességéhez viszonyítva 100%-ra állítja.
</details>

## 8. Melyik tulajdonság ad térközt a szöveg karakterei között?
- [ ] A) `letter-spacing`
- [ ] B) `word-spacing`
- [ ] C) `text-spacing`
- [ ] D) `line-spacing`

<details>
<summary>Megoldás</summary>

**A) `letter-spacing`**

A `letter-spacing` állítja be a karakterek közötti térközt.
</details>

## 9. Hogyan lehet elrejteni egy elemet a képernyőről?
- [ ] A) `visibility: none;`
- [ ] B) `display: none;`
- [ ] C) `hidden: true;`
- [ ] D) `opacity: 0;`

<details>
<summary>Megoldás</summary>

**B) `display: none;`**

A `display: none;` teljesen eltünteti az elemet a képernyőről és a dokumentum elrendezéséből.
</details>

## 10. Melyik szabály hoz létre egy árnyékot egy elem körül?
- [ ] A) `shadow: 2px 2px 5px gray;`
- [ ] B) `box-shadow: 2px 2px 5px gray;`
- [ ] C) `element-shadow: 2px 2px 5px gray;`
- [ ] D) `text-shadow: 2px 2px 5px gray;`

<details>
<summary>Megoldás</summary>

**B) `box-shadow: 2px 2px 5px gray;`**

A `box-shadow` tulajdonság hoz létre árnyékot egy elem körül. A `text-shadow` pedig szövegre alkalmazható.
</details>

## Kombinált HTML és CSS Kérdések

## 1. Hogyan lehet egy gombot piros háttérrel és fehér szöveggel létrehozni?
- [ ] A) `<button style="background: white; color: red;">Gomb</button>`
- [ ] B) `<button style="background-color: red; color: white;">Gomb</button>`
- [ ] C) `<button style="bgcolor: red; text-color: white;">Gomb</button>`
- [ ] D) `<button style="color: red; background: white;">Gomb</button>`

<details>
<summary>Megoldás</summary>

**B) `<button style="background-color: red; color: white;">Gomb</button>`**

A `background-color` állítja be a háttérszínt, a `color` pedig a szöveg színét.
</details>

## 2. Melyik HTML elem és CSS tulajdonság használható egy táblázat celláinak szegélyezésére?
- [ ] A) `<td>` és `border-style: solid;`
- [ ] B) `<table>` és `border-color: black;`
- [ ] C) `<tr>` és `outline: 1px solid black;`
- [ ] D) `<th>` és `border: none;`

<details>
<summary>Megoldás</summary>

**A) `<td>` és `border-style: solid;`**

A `<td>` elem a táblázat celláit jelöli, a `border-style: solid;` pedig szegélyt ad hozzájuk.
</details>

## 3. Hogyan lehet egy képre rárakni egy fekete, félig átlátszó réteget CSS segítségével?
- [ ] A) `<div style="background-color: rgba(0, 0, 0, 0.5); position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>`
- [ ] B) `<img style="overlay: black 50%;">`
- [ ] C) `<div style="opacity: 0.5; background: black;"></div>`
- [ ] D) `<img style="filter: brightness(50%);">`

<details>
<summary>Megoldás</summary>

**A) `<div style="background-color: rgba(0, 0, 0, 0.5); position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>`**

Az `rgba(0, 0, 0, 0.5)` fekete színt ad 50%-os átlátszósággal, a `position: absolute;` pedig a kép fölé helyezi a réteget.
</details>

## 4. Melyik HTML elem és CSS tulajdonság használható egy lenyíló menü létrehozására?
- [ ] A) `<select>` és `dropdown: true;`
- [ ] B) `<div>` és `display: dropdown;`
- [ ] C) `<ul>` és `list-style: dropdown;`
- [ ] D) `<nav>` és `menu-type: dropdown;`

<details>
<summary>Megoldás</summary>

**A) `<select>` és `dropdown: true;`**

A `<select>` elem alapértelmezett lenyíló menüt hoz létre. A CSS-sel tovább stílusozható.
</details>

## 5. Hogyan lehet egy beviteli mezőt (input) lekerekített sarkúra formázni?
- [ ] A) `<input style="round: 5px;">`
- [ ] B) `<input style="border-radius: 5px;">`
- [ ] C) `<input style="corner-radius: 5px;">`
- [ ] D) `<input style="shape: rounded;">`

<details>
<summary>Megoldás</summary>

**B) `<input style="border-radius: 5px;">`**

A `border-radius` tulajdonság állítja be az elem sarkainak lekerekítését.
</details>

# ECMAScript/JavaScript Tesztkérdések

## 1. Mi az ECMAScript?
- [ ] A) Egy új programozási nyelv
- [ ] B) A JavaScript szabványosított specifikációja 
- [ ] C) Egy JavaScript keretrendszer
- [ ] D) A böngészők JavaScript motorja

<details>
<summary>Megoldás</summary>
<b>B) A JavaScript szabványosított specifikációja</b>

Az ECMAScript a JavaScript nyelv szabványa, amelyet az ECMA International szervezet tart karban. A JavaScript az ECMAScript egy implementációja.
</details>

## 2. Melyik évben jelent meg az ES6 (ES2015)?
- [ ] A) 2010
- [ ] B) 2015 
- [ ] C) 2018
- [ ] D) 2009

<details>
<summary>Megoldás</summary>
<b>B) 2015</b>

Az ES6 (vagy ES2015) jelentős újításokat hozott, mint például a `let`/`const`, arrow függvények, osztályok stb.
</details>

## 3. Milyen típusú scope-ot hoz létre a `let` kulcsszó?
- [ ] A) Function scope
- [ ] B) Global scope
- [ ] C) Block scope 
- [ ] D) Module scope

<details>
<summary>Megoldás</summary>
<b>C) Block scope</b>

A `let` (és `const`) blokk szintű hatókört hoz létre, ellentétben a `var`-ral, ami function scope-ot hoz létre.
</details>

## 4. Mi lesz a kimenet?
```javascript
console.log(typeof null);
```
- [ ] A) "null"
- [ ] B) "undefined"
- [ ] C) "object" 
- [ ] D) "number"

<details> 
<summary>Megoldás</summary> <b>C) "object"</b>

Ez a JavaScript egyik ismert "bugja", amelyet a kompatibilitás miatt megtartottak.

</details>

## 5. Melyik NEM igaz az arrow függvényekre?

- [ ] A) Nincs saját this kontextusuk
- [ ] B) Nincs arguments objektumuk
- [ ] C) Használhatók konstruktorként 
- [ ] D) Név nélkül is létrehozhatók

<details> <summary>Megoldás</summary> <b>C) Használhatók konstruktorként</b>

Arrow függvények nem használhatók konstruktorként, hibát dobna a new operátorral való használatuk.

</details>


## 6. Mi a különbség a == és === operátorok között?

- [ ] A) A == érték és típus ellenőrzést is végez
- [ ] B) A === csak érték egyezést vizsgál
- [ ] C) A == típuskonverziót végez, a === nem 
- [ ] D) Nincs különbség közöttük

<details> <summary>Megoldás</summary> <b>C) A `==` típuskonverziót végez, a `===` nem</b>
A === szigorú egyenlőségvizsgálatot végez, míg a == típuskonverziót (type coercion) alkalmaz.

</details>

## 7. Mi lesz a kimenet?

javascript
const arr = [1, 2, 3];
const [x, , y] = arr;
console.log(x, y);
- [ ] A) 1 3 
- [ ] B) 1 2
- [ ] C) 2 3
- [ ] D) undefined undefined

<details> <summary>Megoldás</summary> <b>A) 1 3</b>
Ez egy array destructuring példa, ahol kihagyjuk a második elemet a vesszővel.

</details>

## 8. Mire szolgál a use strict mód?

- [ ] A) Gyorsabb kódot eredményez
- [ ] B) Szigorúbb szintaxis-ellenőrzést tesz lehetővé 
- [ ] C) Automatikus típuskonverziót tiltja
- [ ] D) Csak TypeScript-ben használatos

<details> <summary>Megoldás</summary> <b>B) Szigorúbb szintaxis-ellenőrzést tesz lehetővé</b>
A strict mód számos korábban csendes hibát láthatóvá tesz, és letilt bizonyos nem biztonságos nyelvi elemeket.

</details>

## 9. Mi lesz a kimenet?

javascript
function greet() {
  return () => console.log(this.name);
}

const obj = { name: 'Alice', greet };
const fn = obj.greet();
fn();
- [ ] A) undefined
- [ ] B) "Alice" 
- [ ] C) ReferenceError
- [ ] D) ""

<details> <summary>Megoldás</summary> <b>B) "Alice"</b>
Az arrow függvény megtartja a szülő kontextus this értékét, ami ebben az esetben az obj objektum.

</details>

## 10. Melyik ES6+ funkció engedi a string interpolációt?

- [ ] A) Template literals 
- [ ] B) String.prototype.format
- [ ] C) String interpolation
- [ ] D) String templates

<details> <summary>Megoldás</summary> <b>A) Template literals</b>
Backtick (`) karakterek között használhatóak, pl.: Hello ${name}

</details>

## 11. Mi a különbség a null és undefined között?

- [ ] A) null a hiányzó értéket, undefined a szándékos üres értéket jelenti
- [ ] B) undefined a hiányzó értéket, null a szándékos üres értéket jelenti 
- [ ] C) Nincs lényegi különbség
- [ ] D) null primitív típus, undefined nem

<details> <summary>Megoldás</summary> <b>B) `undefined` a hiányzó értéket, `null` a szándékos üres értéket jelenti</b>
undefined azt jelenti, hogy egy változó nincs értékhez rendelve, null szándékos üres érték.

</details>

## 12. Melyik NEM igaz a Promise-okra?

- [ ] A) Három állapotuk lehet: pending, fulfilled, rejected
- [ ] B) Láncolhatóak a .then() metódussal
- [ ] C) Szinkron módon futnak le 
- [ ] D) Kezelhetik az aszinkron műveleteket

<details> <summary>Megoldás</summary> <b>C) Szinkron módon futnak le</b>
A Promise-ok aszinkron műveletek kezelésére szolgálnak, tehát aszinkron módon futnak le.

</details>

## 13. Mi lesz a kimenet?

javascript
const obj = { a: 1, b: 2 };
const { a: x, b: y } = obj;
console.log(x, y);
- [ ] A) 1 2 
- [ ] B) a b
- [ ] C) undefined undefined
- [ ] D) { a: 1 } { b: 2 }

<details> <summary>Megoldás</summary> <b>A) 1 2</b>
Ez objektum destructuring, ahol az obj.a értékét az x változóba, az obj.b értékét az y változóba rendeljük.

</details>

## 14. Melyik metódus NEM változtatja meg az eredeti tömböt?

- [ ] A) push
- [ ] B) splice
- [ ] C) map 
- [ ] D) sort

<details> <summary>Megoldás</summary> <b>C) map</b>
A map létrehoz egy új tömböt, nem módosítja az eredetit (immutable művelet).

</details>

## 15. Mi a hoisting?

- [ ] A) A változók automatikus inicializálása undefined értékkel
- [ ] B) A függvények és változók deklarációjának "felhozása" a scope tetejére 
- [ ] C) A kód minifikálása
- [ ] D) A memóriakezelés JavaScript-ben

<details> <summary>Megoldás</summary> <b>B) A függvények és változók deklarációjának "felhozása" a scope tetejére</b>
A JavaScript a változó- és függvénydeklarációkat a scope elejére "hozza", ezért lehet őket a deklaráció előtt is hivatkozni.

</details>

## 16. Mi lesz a kimenet?

javascript
async function getData() {
  return await Promise.resolve('Hello');
}

getData().then(console.log);
- [ ] A) undefined
- [ ] B) Promise {`<pending>`}
- [ ] C) "Hello" 
- [ ] D) Error

<details> <summary>Megoldás</summary> <b>C) "Hello"</b>
Az async függvény automatikusan Promise-t ad vissza, és az await kifejti a Promise értékét.

</details>

## 17. Melyik NEM JavaScript adatszerkezet?

- [ ] A) Set
- [ ] B) Map
- [ ] C) Array
- [ ] D) Tuple 

<details> <summary>Megoldás</summary> <b>D) Tuple</b>
A Tuple nem natív JavaScript adatszerkezet (TypeScript-ben létezik).

</details>

## 18. Mi a closure lényege?

- [ ] A) Függvényen belüli függvény, ami hozzáfér a szülő scope változóihoz 
- [ ] B) A memória felszabadítása
- [ ] C) Az objektumok egymásba ágyazása
- [ ] D) A prototípus láncolat

<details> <summary>Megoldás</summary> <b>A) Függvényen belüli függvény, ami hozzáfér a szülő scope változóihoz</b>
A closure egy függvény, ami "emlékszik" a létrehozásakor érvényes környezet változóira.

</details>

## 19. Mi lesz a kimenet?

javascript
const num = 0;
console.log(num ?? 42);
- [ ] A) 0 
- [ ] B) 42
- [ ] C) null
- [ ] D) undefined

<details> <summary>Megoldás</summary> <b>A) 0</b>
A nullish coalescing operátor (??) csak akkor adja vissza a jobb oldali értéket, ha a bal oldali null vagy undefined.

</details>

## 20. Melyik NEM igaz a JavaScript modulokra?

- [ ] A) Használhatják az export és import szintaxist
- [ ] B) Automatikusan strict módban futnak
- [ ] C) Minden változó globális scope-ban van 
- [ ] D) Használhatók top-level await-et

<details> <summary>Megoldás</summary> <b>C) Minden változó globális scope-ban van</b>
Modulokban a változók alapértelmezés szerint nem globálisak, hanem modul scope-ban élnek.

</details> ```

# Tiszta Kód (Clean Code) Alapelvek Tesztkérdések

## Elméleti Kérdések

## 1. Mi a tiszta kód legfontosabb jellemzője?
- [ ] A) Gyors futási idő
- [ ] B) Könnyű olvashatóság és karbantarthatóság
- [ ] C) Minimális sorok száma
- [ ] D) Komplex algoritmusok használata

<details>
<summary>Megoldás</summary>
<b>B) Könnyű olvashatóság és karbantarthatóság</b>

A tiszta kód elsődleges célja, hogy más fejlesztők (és a jövőbeli önmagunk) könnyen megértsék és módosítsák a kódot.
</details>

## 2. Milyen hosszú legyen ideálisan egy függvény?
- [ ] A) Maximum 50 sor
- [ ] B) Maximum 20 sor
- [ ] C) Annyi sor, amennyi szükséges
- [ ] D) Mindig egy képernyőnyi

<details>
<summary>Megoldás</summary>
<b>B) Maximum 20 sor</b>

A Clean Code elvei szerint egy függvény legyen rövid (ideálisan 3-4 sor), de maximum 20 sor. "Nem lehet túl rövid."
</details>

## 3. Mi az "Single Responsibility Principle" (SRP)?
- [ ] A) Minden osztálynak csak egy metódusa legyen
- [ ] B) Minden modul/függvény csak egy felelősséggel rendelkezzen
- [ ] C) Minden programnak csak egy fő funkciója legyen
- [ ] D) Minden változó csak egy értéket tároljon

<details>
<summary>Megoldás</summary>
<b>B) Minden modul/függvény csak egy felelősséggel rendelkezzen</b>

Az SRP szerint egy függvény/oszály csak egy okból változzon, és csak egy szerepet töltsön be.
</details>

## 4. Miért fontos a konzisztens elnevezési konvenció?
- [ ] A) Csak az esztétikai megjelenés miatt
- [ ] B) A kód olvashatóságának és a csapatmunka elősegítésére
- [ ] C) A fordító optimalizálhassa a kódot
- [ ] D) Kötelező a nyelvi specifikációban

<details>
<summary>Megoldás</summary>
<b>B) A kód olvashatóságának és a csapatmunka elősegítésére</b>

Konzisztens elnevezések (pl. `camelCase`, `PascalCase`) segítik a kód megértését és csökkentik a hibák kockázatát.
</details>

## 5. Mit jelent a "DRY" elv?
- [ ] A) "Don't Repeat Yourself" - Ne ismételd magad
- [ ] B) "Do Repeat Yearly" - Évente ismételd meg
- [ ] C) "Deeply Recursive Yields" - Mély rekurzió használata
- [ ] D) "Data-Rich YAML" - Adatgazdag YAML használata

<details>
<summary>Megoldás</summary>
<b>A) "Don't Repeat Yourself" - Ne ismételd magad</b>

A DRY elv szerint minden tudásnak egyértelmű, egyedülálló és hiteles reprezentációval kell rendelkeznie a rendszerben.
</details>

## 6. Mi a "code smell"?
- [ ] A) A kód fizikai szaga
- [ ] B) Olyan kódminták, amelyek problémákra utalhatnak
- [ ] C) A kód kommentjeinek minősége
- [ ] D) A változók elnevezésének stílusa

<details>
<summary>Megoldás</summary>
<b>B) Olyan kódminták, amelyek problémákra utalhatnak</b>

Példák: hosszú függvények, mágikus számok, mély egymásba ágyazás, duplikált kód.
</details>

## 7. Mit jelent a "Boy Scout Rule" a tiszta kódban?
- [ ] A) Mindig hagyjuk tisztábban a kódot, mint ahogy találtuk
- [ ] B) Csak érett fejlesztők írhatnak kódot
- [ ] C) Minden függvényt dokumentálni kell
- [ ] D) Kódolás előtt mindig tervezzünk

<details>
<summary>Megoldás</summary>
<b>A) Mindig hagyjuk tisztábban a kódot, mint ahogy találtuk</b>

Minden kismértékű módosításnál javítsunk valamit a kódban (pl. elnevezés, struktúra).
</details>

## 8. Mi a "Law of Demeter"?
- [ ] A) Egy objektum csak a saját tagjait és közvetlen függvényeit használja
- [ ] B) Minden osztálynak legyen destruktora
- [ ] C) A kódnak követnie kell egy demokratikus struktúrát
- [ ] D) Csak demeter nevű változókat használjunk

<details>
<summary>Megoldás</summary>
<b>A) Egy objektum csak a saját tagjait és közvetlen függvényeit használja</b>

Más szavakkal: "Ne beszélj idegenekkel", vagyis ne hívj meg láncolt hívásokat (pl. `objA.getB().getC().doSomething()`).
</details>

## 9. Mi a helyes sorrend a refaktorálás lépéseihez?
- [ ] A) Tesztek írása → Refaktorálás → Funkció hozzáadása
- [ ] B) Refaktorálás → Tesztek írása → Dokumentálás
- [ ] C) Funkció hozzáadása → Tesztek írása → Refaktorálás
- [ ] D) Dokumentálás → Refaktorálás → Tesztek írása

<details>
<summary>Megoldás</summary>
<b>A) Tesztek írása → Refaktorálás → Funkció hozzáadása</b>

Először írjunk teszteket, hogy biztosítsuk a működést, majd refaktoráljunk, végül adjunk hozzá új funkciókat.
</details>

## 10. Mit jelent a "YAGNI" elv?
- [ ] A) "You Aren't Gonna Need It" - Nem fogsz rá szükséged van
- [ ] B) "You Always Get New Ideas" - Mindig új ötleteid lesznek
- [ ] C) "Your Algorithms Get Nicer Iteratively" - Algoritmusok fokozatos javítása
- [ ] D) "Yielding Agile New Interfaces" - Új interfészek gyártása

<details>
<summary>Megoldás</summary>
<b>A) "You Aren't Gonna Need It" - Nem fogsz rá szükséged van</b>

Ne implementálj funkciókat "majd ha kell" alapon, csak a jelenlegi követelményekre fókuszálj.
</details>

## Gyakorlati Kérdések

## 1. Melyik változónév felel meg jobban a tiszta kód elveinek?

```javascript
// Opciók:
let d; // A) Napok száma
let daysSinceLastLogin; // B)
let elapsedDays; // C)
let x1; // D)
```

- [ ]  A) Kisebb függvényekre bontanám

- [ ]  B) Használnék map és filter metódusokat

- [ ]  C) Mindkettő

- [ ]  D) Egyik sem, a kód rendben van

<details> <summary>Megoldás</summary> <b>C) Mindkettő</b>
Példa refaktorált változat:

```javascript
function isActive(item) {
  return item.active;
}

function calculateAdjustedValue(item) {
  return item.value * 1.1;
}

function processData(data) {
  return data.filter(isActive).map(calculateAdjustedValue);
}
```

</details>

## 3. Melyik kód szegíti a DRY elvet?

```javascript
// A)
function calculateCircleArea(r) {
  return Math.PI * r * r;
}
function calculateCircleCircumference(r) {
  return 2 * Math.PI * r;
}

// B)
function getUserRoles(user) {
  if (user.age > 18) {
    return ['admin', 'editor'];
  } else {
    return ['guest'];
  }
}
function canEditContent(user) {
  if (user.age > 18) {
    return true;
  } else {
    return false;
  }
}
```

- [ ] A)

- [ ] B)

- [ ] C) Mindkettő

- [ ] ) Egyik sem

<details> <summary>Megoldás</summary> <b>B)</b>
A B) példában az user.age > 18 feltétel ismétlődik, ami sérti a DRY elvet. Megoldás: egy segédfüggvény létrehozása (pl. isAdult(user)).

</details>

## 4. Melyik kód tartalmaz "mágikus számot"?

```javascript
// A)
const taxRate = 0.2;
function calculateTotal(price) {
  return price * (1 + taxRate);
}

// B)
function calculateDiscount(price) {
  return price * 0.15;
}
```
- [ ] A)

- [ ] B)

- [ ] C) Mindkettő

- [ ] D) Egyik sem

<details> <summary>Megoldás</summary> <b>B)</b>
A 0.15 érték a B) példában "mágikus szám". Jó gyakorlat konstanssal helyettesíteni (pl. const STANDARD_DISCOUNT = 0.15).

</details>

## 5. Hogyan javítanád ezt az osztályt az SRP alapján?

```javascript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  saveToDatabase() {
    // Adatbázis mentés logika
  }

  sendWelcomeEmail() {
    // Email küldés logika
  }

  validate() {
    // Validáció logika
  }
}
```

- [ ] A) Külön osztályokra bontanám (UserRepository, EmailService, UserValidator)

- [ ] B) Összevonám a metódusokat egy nagy metódusba

- [ ] C) Törölném a validate metódust

- [ ] D) Hagynám így, mert helyes

<details> <summary>Megoldás</summary> <b>A) Külön osztályokra bontanám (UserRepository, EmailService, UserValidator)</b>
Az osztály jelenleg három felelősséget vállal (adattárolás, email küldés, validáció), ami sérti az SRP-t.

</details>

## 6. Melyik komment felesleges tiszta kódban?

```javascript
// A) Calculate total price including tax
function calculateTotal(price, tax) {
  return price * (1 + tax);
}

// B) TODO: Implement error handling here
function processOrder(order) {
  // Belső logika
}

// C) This is a constructor
class User {
  constructor(name) {
    this.name = name;
  }
}
```
- [ ] A)

- [ ] B)

- [ ] C)

- [ ] D) Egyik sem

<details> <summary>Megoldás</summary> <b>C)</b>
Az A) komment hasznos, ha a függvény neve nem egyértelmű (bár ideális esetben a függvény nevét kéne javítani). A B) komment hasznos emlékeztető. A C) komment teljesen felesleges, mert a kód önmagáért beszél.

</details>

## 7. Melyik kód sérti a "Law of Demeter"-t?

```javascript
// A)
const total = order.getTotal();

// B)
const street = customer.getAddress().getStreet();

// C)
const isValid = user.validate();
```

- [ ] A)

- [ ] B)

- [ ] C)

- [ ] D) Egyik sem

<details> <summary>Megoldás</summary> <b>B)</b>
A B) példában láncolt metódushívás (getAddress().getStreet()) van, ami sérti a Law of Demeter-t. Jobb megoldás lenne pl. customer.getStreet().

</details>

## 8. Hogyan lehet ezt a kódot tömörebbé és olvashatóbbá tenni?

```javascript
function getStatus(isActive, isAdmin) {
  if (isActive === true) {
    if (isAdmin === true) {
      return 'Active Admin';
    } else {
      return 'Active User';
    }
  } else {
    return 'Inactive';
  }
}
```
- [ ] A) Használjunk switch utasítást

- [ ] B) Használjunk ternáris operátort

- [ ] C) Használjunk korai visszatérést és egyszerű feltételeket

- [ ] D) Hagyjuk így, mert egyértelmű

<details> <summary>Megoldás</summary> <b>C) Használjunk korai visszatérést és egyszerű feltételeket</b>
Példa refaktorált változat:

```javascript
function getStatus(isActive, isAdmin) {
  if (!isActive) return 'Inactive';
  return isAdmin ? 'Active Admin' : 'Active User';
}
```
</details>

## 9. Melyik kód követi a Clean Code elveket?

```javascript
// A)
function fn(a, b) {
  return a * b + 2;
}

// B)
function calculateTotalWithTax(basePrice, taxRate) {
  const taxAmount = basePrice * taxRate;
  return basePrice + taxAmount;
}

// C)
function x(y, z) {
  let r = y * z;
  return r + 2;
}
```
- [ ] A)

- [ ] B)

- [ ] C)

- [ ] D) Mindhárom

<details> <summary>Megoldás</summary> <b>B)</b>
A B) példa használ leíró neveket és egyértelmű változókat, míg az A) és C) példák tömör, de félreérthető neveket használnak.

</details>

## 10. Hogyan javítanád ezt a kódot a Clean Code alapján?

```javascript
function update() {
  let a = getUserData();
  let b = processData(a);
  let c = validate(b);
  if (c) {
    saveToDb(b);
    sendNotification(b);
  }
}
```
- [ ] A) Használjunk értelmes változóneveket

- [ ] B) Bontsuk kisebb függvényekre

- [ ] C) Mindkettő

- [ ] D) Hagyjuk így, mert jól működik

<details> <summary>Megoldás</summary> <b>C) Mindkettő</b>
Példa refaktorált változat:

```javascript
function updateUser() {
  const userData = getUserData();
  const processedData = processUserData(userData);
  if (isValidUserData(processedData)) {
    saveUserToDatabase(processedData);
    sendUserNotification(processedData);
  }
}
```
</details> 

# Adatbázis kezelés, Tesztelés és SQL Tesztkérdések

## 1. Mi a PRIMARY KEY fő jellemzője?
- [ ] A) Mindig egyetlen oszlopból áll
- [ ] B) Egyediséget és nem-null értéket biztosít 
- [ ] C) Csak számokat tartalmazhat
- [ ] D) Automatikusan indexelődik csökkenő sorrendben

<details>
<summary>Megoldás</summary>
<b>B) Egyediséget és nem-null értéket biztosít</b>

A PRIMARY KEY egyedivé teszi az adatsort és nem enged meg NULL értéket. Több oszlopból is állhat (összetett kulcs).
</details>

## 2. Melyik SQL parancs töröl egy táblát?
- [ ] A) DELETE TABLE
- [ ] B) DROP TABLE 
- [ ] C) REMOVE TABLE
- [ ] D) TRUNCATE TABLE

<details>
<summary>Megoldás</summary>
<b>B) DROP TABLE</b>

A DROP TABLE teljesen eltávolítja a táblát az adatbázisból. A TRUNCATE TABLE csak az adatokat törli, a tábla szerkezetét meghagyja.
</details>

## 3. Mi a különbség a WHERE és HAVING között?
- [ ] A) A WHERE sorok szűrésére, a HAVING csoportok szűrésére szolgál 
- [ ] B) A HAVING csak JOIN műveleteknél használható
- [ ] C) A WHERE csak numerikus mezőkre alkalmazható
- [ ] D) Nincs lényegi különbség

<details>
<summary>Megoldás</summary>
<b>A) A WHERE sorok szűrésére, a HAVING csoportok szűrésére szolgál</b>

A WHERE a GROUP BY előtt szűr, a HAVING a GROUP BY után, aggregált értékekre.
</details>

## 4. Mit jelent az ACID a tranzakciókezelésben?
- [ ] A) Atomicity, Consistency, Isolation, Durability 
- [ ] B) Access, Control, Integrity, Data
- [ ] C) Algorithm, Cache, Index, Database
- [ ] D) Authentication, Cryptography, Identification, Decryption

<details>
<summary>Megoldás</summary>
<b>A) Atomicity, Consistency, Isolation, Durability</b>

Az ACID a tranzakciók négy alapvető tulajdonságát írja le: atomiság, konzisztencia, izoláltság, tartósság.
</details>

## 5. Melyik NEM NoSQL adatbázis típus?
- [ ] A) Dokumentum-orientált (MongoDB)
- [ ] B) Kulcs-érték (Redis)
- [ ] C) Gráf (Neo4j)
- [ ] D) Relációs (MySQL) 

<details>
<summary>Megoldás</summary>
<b>D) Relációs (MySQL)</b>

A MySQL relációs adatbázis, nem tartozik a NoSQL kategóriába.
</details>

## 6. Mi a célja az adatbázis normalizálásának?
- [ ] A) Az adatok redundanciájának csökkentése és inkonzisztencia elkerülése 
- [ ] B) Az adatbázis teljesítményének maximalizálása
- [ ] C) Az adatok titkosítása
- [ ] D) Az adatbázis méretének növelése

<details>
<summary>Megoldás</summary>
<b>A) Az adatok redundanciájának csökkentése és inkonzisztencia elkerülése</b>

A normalizálás fő célja az adatintegritás biztosítása redundancia csökkentéssel, bár néha csökkentheti a teljesítményt.
</details>

## 7. Melyik SQL parancs frissít adatokat?
- [ ] A) MODIFY
- [ ] B) ALTER
- [ ] C) UPDATE 
- [ ] D) CHANGE

<details>
<summary>Megoldás</summary>
<b>C) UPDATE</b>

Példa: `UPDATE users SET name = 'John' WHERE id = 1;`
</details>

## 8. Mi a különbség az INNER JOIN és LEFT JOIN között?
- [ ] A) Az INNER JOIN csak egyező rekordokat ad vissza, a LEFT JOIN minden bal oldalit 
- [ ] B) A LEFT JOIN gyorsabb
- [ ] C) Az INNER JOIN csak numerikus mezőkre működik
- [ ] D) Nincs különbség

<details>
<summary>Megoldás</summary>
<b>A) Az INNER JOIN csak egyező rekordokat ad vissza, a LEFT JOIN minden bal oldalit</b>

A LEFT JOIN a bal oldali tábla minden sorát megtartja, még ha nincs is egyezés a jobb oldalon.
</details>

## 9. Mi a célja az adatbázis indexeknek?
- [ ] A) Az adatok biztonsági mentése
- [ ] B) Gyorsabb keresés és rendezés lehetősége 
- [ ] C) Az adatok tömörítése
- [ ] D) Az adatbázis méretének csökkentése

<details>
<summary>Megoldás</summary>
<b>B) Gyorsabb keresés és rendezés lehetősége</b>

Az indexek gyorsabbá teszik a lekérdezéseket, de lassítják az INSERT/UPDATE/DELETE műveleteket.
</details>

## 10. Mit jelent az SQL injection?
- [ ] A) Adatbázis biztonsági mentési módszer
- [ ] B) Kártevő kód befecskendezése SQL parancsokba 
- [ ] C) Adatok importálása CSV fájlból
- [ ] D) SQL parancsok automatikus generálása

<details>
<summary>Megoldás</summary>
<b>B) Kártevő kód befecskendezése SQL parancsokba</b>

Megelőzése: paraméterezett lekérdezések, prepared statements használata.
</details>

## 11. Melyik NORMÁLFORMÁVAL kapcsolatos állítás hamis?
- [ ] A) 1NF: Minden attribútum atomi
- [ ] B) 2NF: 1NF + nincs parciális függés
- [ ] C) 3NF: 2NF + nincs tranzitív függés
- [ ] D) Minden adatbázisnak el kell érnie a 5NF-et 

<details>
<summary>Megoldás</summary>
<b>D) Minden adatbázisnak el kell érnie a 5NF-et</b>

A gyakorlatban a 3NF vagy BCNF is gyakran elegendő, a 5NF ritkán szükséges.
</details>

## 12. Mi a különbség a TRUNCATE és DELETE között?
- [ ] A) A TRUNCATE nem naplózott művelet, a DELETE igen 
- [ ] B) A DELETE csak egy sort töröl egyszerre
- [ ] C) A TRUNCATE visszavonható
- [ ] D) Nincs különbség

<details>
<summary>Megoldás</summary>
<b>A) A TRUNCATE nem naplózott művelet, a DELETE igen</b>

A TRUNCATE gyorsabb, mert nem naplózza az egyes sorok törlését, de nem visszavonható.
</details>

## 13. Mire szolgál a GROUP BY záradék?
- [ ] A) Adatok rendezésére
- [ ] B) Sorok csoportosítására aggregálás előtt 
- [ ] C) Táblák összekapcsolására
- [ ] D) Lekérdezési eredmények szűrésére

<details>
<summary>Megoldás</summary>
<b>B) Sorok csoportosítására aggregálás előtt</b>

Példa: `SELECT department, COUNT(*) FROM employees GROUP BY department;`
</details>

## 14. Mi a NULL érték jellege SQL-ben?
- [ ] A) Üres string ('')
- [ ] B) 0 érték
- [ ] C) Ismeretlen vagy hiányzó adat 
- [ ] D) False logikai érték

<details>
<summary>Megoldás</summary>
<b>C) Ismeretlen vagy hiányzó adat</b>

A NULL nem egyenlő semmivel, még egy másik NULL-lal sem (IS NULL vagy IS NOT NULL használata szükséges).
</details>

## 15. Melyik NEM relációs algebrai művelet?
- [ ] A) Projekció
- [ ] B) Szelekció
- [ ] C) Join
- [ ] D) Hashing 

<details>
<summary>Megoldás</summary>
<b>D) Hashing</b>

Alapvető relációs műveletek: szelekció (σ), projekció (π), Descartes-szorzat (×), unió (∪), különbség (-), átnevezés (ρ).
</details>

## 16. Mit jelent a CAP tétel?
- [ ] A) Consistency, Availability, Partition tolerance - csak kettő érhető el egyszerre 
- [ ] B) A tranzakciók három lépése: Commit, Abort, Process
- [ ] C) Adatbázis tervezési elvek: Compactness, Access, Performance
- [ ] D) SQL lekérdezések optimalizálási stratégiája

<details>
<summary>Megoldás</summary>
<b>A) Consistency, Availability, Partition tolerance - csak kettő érhető el egyszerre</b>

A CAP tétel szerint elosztott rendszerben egyszerre csak kettő biztosítható a három tulajdonság közül.
</details>

## 17. Mire való a VIEW SQL-ben?
- [ ] A) Virtuális tábla létrehozására 
- [ ] B) Adatbázis struktúra megjelenítésére
- [ ] C) Teljesítmény statisztikák megtekintésére
- [ ] D) Biztonsági mentések készítésére

<details>
<summary>Megoldás</summary>
<b>A) Virtuális tábla létrehozására</b>

A VIEW egy mentett SQL lekérdezés, amely virtuális táblaként viselkedik.
</details>

## 18. Mi a célja a tesztelési piramisnak?
- [ ] A) A tesztelési rétegek arányos elosztását mutatja 
- [ ] B) A tesztelési esetek prioritizálását
- [ ] C) A tesztelési eszközök kategorizálását
- [ ] D) A tesztelési költségek becslését

<details>
<summary>Megoldás</summary>
<b>A) A tesztelési rétegek arányos elosztását mutatja</b>

Alul egységtesztek (sok), középen integrációs tesztek, felül end-to-end tesztek (kevés).
</details>

## 19. Melyik NEM egy tesztelési módszer?
- [ ] A) Fehér dobozos tesztelés
- [ ] B) Fekete dobozos tesztelés
- [ ] C) Szürke dobozos tesztelés
- [ ] D) Kék dobozos tesztelés 

<details>
<summary>Megoldás</summary>
<b>D) Kék dobozos tesztelés</b>

Ismeretes típusok: fehér dobozos (strukturális), fekete dobozos (funkcionális), szürke dobozos (kettő kombinációja).
</details>

## 20. Mi a különbség a unit és integration test között?
- [ ] A) Unit teszt egyetlen komponenst, integrációs teszt komponensek együttműködését vizsgálja 
- [ ] B) Unit teszt csak frontend kódra használható
- [ ] C) Integrációs teszt gyorsabb
- [ ] D) Nincs lényegi különbség

<details>
<summary>Megoldás</summary>
<b>A) Unit teszt egyetlen komponenst, integrációs teszt komponensek együttműködését vizsgálja</b>

Unit tesztek izoláltan futnak, gyorsak; integrációs tesztek külső függőségeket is használnak.
</details>

## 21. Mi a TDD lényege?
- [ ] A) Először teszteket írni, majd implementálni a funkcionalitást 
- [ ] B) Tesztek írása az implementáció után
- [ ] C) Automatikus tesztgenerálás
- [ ] D) Tesztelési dokumentáció készítése

<details>
<summary>Megoldás</summary>
<b>A) Először teszteket írni, majd implementálni a funkcionalitást</b>

TDD = Test-Driven Development: piros -> zöld -> refaktor ciklus.
</details>

## 22. Melyik NEM egy tesztelési keretrendszer?
- [ ] A) JUnit
- [ ] B) Selenium
- [ ] C) Mockito
- [ ] D) Spring Boot 

<details>
<summary>Megoldás</summary>
<b>D) Spring Boot</b>

Spring Boot egy alkalmazáskeretrendszer, nem tesztelési keretrendszer.
</details>

## 23. Mit jelent a mocking tesztelésnél?
- [ ] A) Valós objektumok szimulálása teszteléshez 
- [ ] B) Tesztesetek véletlenszerű generálása
- [ ] C) Teszt futási idő mérése
- [ ] D) Teszt eredmények vizualizálása

<details>
<summary>Megoldás</summary>
<b>A) Valós objektumok szimulálása teszteléshez</b>

Mock objektumok vezérelt viselkedést biztosítanak függőségek helyett.
</details>

## 24. Mi a célja a CI/CD-nek?
- [ ] A) Automatizált buildelés, tesztelés és telepítés 
- [ ] B) Adatbázis migráció kezelése
- [ ] C) Kód minőségének kézi ellenőrzése
- [ ] D) Felhasználói dokumentáció generálása

<details>
<summary>Megoldás</summary>
<b>A) Automatizált buildelés, tesztelés és telepítés</b>

CI = Continuous Integration, CD = Continuous Delivery/Deployment.
</details>

## 25. Melyik SQL parancs hoz létre új táblát?
- [ ] A) ADD TABLE
- [ ] B) CREATE TABLE 
- [ ] C) MAKE TABLE
- [ ] D) NEW TABLE

<details>
<summary>Megoldás</summary>
<b>B) CREATE TABLE</b>

Példa: `CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(100));`
</details>

## 26. Mi a különbség a UNION és UNION ALL között?
- [ ] A) UNION kiszűri a duplikátumokat, UNION ALL nem 
- [ ] B) UNION ALL gyorsabb
- [ ] C) UNION csak számokra működik
- [ ] D) Nincs különbség

<details>
<summary>Megoldás</summary>
<b>A) UNION kiszűri a duplikátumokat, UNION ALL nem</b>

UNION ALL nem végez deduplikációt, ezért gyorsabb lehet.
</details>

## 27. Melyik NEM egy tranzakció izolációs szintje?
- [ ] A) READ UNCOMMITTED
- [ ] B) READ COMMITTED
- [ ] C) REPEATABLE READ
- [ ] D) WRITE LOCKED 

<details>
<summary>Megoldás</summary>
<b>D) WRITE LOCKED</b>

Standard izolációs szintek: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE.
</details>

## 28. Mit jelent a denormalizálás?
- [ ] A) Normalizálási szabályok szándékos megszegése teljesítmény javítására 
- [ ] B) Adatbázis biztonsági mentése
- [ ] C) Táblák automatikus optimalizálása
- [ ] D) Adatok tömörítése

<details>
<summary>Megoldás</summary>
<b>A) Normalizálási szabályok szándékos megszegése teljesítmény javítására</b>

Gyakori olvasási műveleteknél használják, az adatredundancia árán.
</details>

## 29. Mire való a EXPLAIN SQL parancs?
- [ ] A) SQL parancsok magyarázata
- [ ] B) Lekérdezési terv megjelenítése optimalizáláshoz 
- [ ] C) Adatbázis séma dokumentálása
- [ ] D) Hibakeresési információk megjelenítése

<details>
<summary>Megoldás</summary>
<b>B) Lekérdezési terv megjelenítése optimalizáláshoz</b>

Megmutatja, hogyan hajtja végre az adatbázis a lekérdezést (indexhasználat, join típusok stb.).
</details>

## 30. Mi a különbség a stored procedure és függvény között?
- [ ] A) Függvény visszatérési értékkel rendelkezik, stored procedure nem kötelező 
- [ ] B) Stored procedure csak paramétereket fogad
- [ ] C) Függvény nem futtatható SQL parancsból
- [ ] D) Nincs különbség

<details>
<summary>Megoldás</summary>
<b>A) Függvény visszatérési értékkel rendelkezik, stored procedure nem kötelező</b>

Függvények SELECT utasításban használhatók, procedure-k CALL paranccsal hívhatók.
</details>
# SQL Alapok Tesztkérdések

## 1. Melyik SQL utasítás felel meg annak, hogy "minden rekordot lekérjünk a 'users' táblából"?
- [ ] A) GET * FROM users
- [ ] B) SELECT ALL FROM users
- [ ] C) SELECT * FROM users
- [ ] D) FETCH * FROM users

<details>
<summary>Megoldás</summary>
<b>C) SELECT * FROM users</b>
Az SQL-ben a SELECT * minden oszlopot lekér a megadott táblából.
</details>

## 2. Melyik wildcard karakter felel meg a "bármilyen hosszúságú karakterláncnak"?
- [ ] A) _
- [ ] B) %
- [ ] C) ?
- [ ] D) *

<details>
<summary>Megoldás</summary>
<b>B) %</b>
Az SQL-ben a % jelöl tetszőleges számú (akár 0) karaktert, míg az _ pontosan egy karaktert.
</details>

## 3. Hogyan kérdezhetjük le a 'products' tábla azon rekordjait, ahol a 'price' értéke 1000 és 5000 között van?
- [ ] A) SELECT * FROM products WHERE price BETWEEN 1000 AND 5000
- [ ] B) SELECT * FROM products WHERE price >= 1000 OR price <= 5000
- [ ] C) SELECT * FROM products WHERE price IN (1000, 5000)
- [ ] D) SELECT * FROM products WHERE 1000 < price > 5000

<details>
<summary>Megoldás</summary>
<b>A) SELECT * FROM products WHERE price BETWEEN 1000 AND 5000</b>
A BETWEEN operátor határokat is beleértve vizsgálja az értékeket.
</details>

## 4. Melyik parancs szúr be új rekordot a 'customers' táblába?
- [ ] A) ADD INTO customers (name, email) VALUES ('John', 'john@example.com')
- [ ] B) INSERT customers (name, email) VALUES ('John', 'john@example.com')
- [ ] C) INSERT INTO customers (name, email) VALUES ('John', 'john@example.com')
- [ ] D) CREATE customers SET name='John', email='john@example.com'

<details>
<summary>Megoldás</summary>
<b>C) INSERT INTO customers (name, email) VALUES ('John', 'john@example.com')</b>
Az INSERT INTO a helyes szintaxis új rekord beszúrásához.
</details>

## 5. Mi lesz a kimenete ennek a lekérdezésnek: SELECT COUNT(*) FROM orders WHERE status = 'shipped'?
- [ ] A) Az összes rendelés listája
- [ ] B) A 'shipped' státuszú rendelések száma
- [ ] C) Az orders tábla összes rekordjának száma
- [ ] D) Csak az első 'shipped' rendelés

<details>
<summary>Megoldás</summary>
<b>B) A 'shipped' státuszú rendelések száma</b>
A COUNT(*) függvény megszámolja a feltételnek megfelelő rekordokat.
</details>

## 6. Melyik NEM relációs adatbázis alapvető fogalma?
- [ ] A) Tábla
- [ ] B) Sor
- [ ] C) Oszlop
- [ ] D) Graf

<details>
<summary>Megoldás</summary>
<b>D) Graf</b>
A gráf nem alapvető fogalma a relációs adatbázisoknak (noSQL gráf adatbázisokban használatos).
</details>

## 7. Melyik MySQL parancs frissíti a 'users' tábla 'email' oszlopát ahol id=1?
- [ ] A) MODIFY users SET email='new@email.com' WHERE id=1
- [ ] B) CHANGE users SET email='new@email.com' WHERE id=1
- [ ] C) UPDATE users SET email='new@email.com' WHERE id=1
- [ ] D) ALTER users SET email='new@email.com' WHERE id=1

<details>
<summary>Megoldás</summary>
<b>C) UPDATE users SET email='new@email.com' WHERE id=1</b>
Az UPDATE a helyes parancs meglévő adatok módosításához.
</details>

## 8. Mit csinál ez a lekérdezés: SELECT name FROM customers ORDER BY registration_date DESC LIMIT 5?
- [ ] A) Az első 5 regisztrált felhasználó nevét adja vissza
- [ ] B) Az utolsó 5 regisztrált felhasználó nevét adja vissza
- [ ] C) Az 5 legrégebbi felhasználó nevét adja vissza
- [ ] D) 5 véletlenszerű felhasználó nevét adja vissza

<details>
<summary>Megoldás</summary>
<b>B) Az utolsó 5 regisztrált felhasználó nevét adja vissza</b>
A DESC csökkenő sorrendet jelent, a LIMIT 5 pedig az első 5 eredményt korlátozza.
</details>

## 9. Melyik NEM táblák közötti kapcsolat típusa?
- [ ] A) Egy-a-többhöz
- [ ] B) Több-a-többhöz
- [ ] C) Egy-az-egyhez
- [ ] D) Hierarchikus

<details>
<summary>Megoldás</summary>
<b>D) Hierarchikus</b>
A hierarchikus kapcsolat nem alapvető relációs adatbázis-kapcsolat (bár megvalósítható).
</details>

## 10. Mi a különbség a WHERE és HAVING között?
- [ ] A) A WHERE sorok szűrésére, a HAVING oszlopok szűrésére szolgál
- [ ] B) A WHERE csoportosítás előtt, a HAVING után szűr
- [ ] C) A WHERE csak SELECT-ben, a HAVING minden parancsban használható
- [ ] D) Nincs különbség, szinonimák

<details>
<summary>Megoldás</summary>
<b>B) A WHERE csoportosítás előtt, a HAVING után szűr</b>
WHERE az egyes rekordokon szűr, HAVING a GROUP BY által létrehozott csoportokon.
</details>
# Mobilfejlesztés Alapok Tesztkérdések

## 1. Melyik NEM mobil alkalmazás típus?
- [ ] A) Natív alkalmazás
- [ ] B) Hibrid alkalmazás
- [ ] C) Progresszív webalkalmazás (PWA)
- [ ] D) Szerveroldali alkalmazás

<details>
<summary>Megoldás</summary>
<b>D) Szerveroldali alkalmazás</b>
A szerveroldali alkalmazások nem mobil specifikus megoldások.
</details>

## 2. Melyik keretrendszer használható hibrid mobilfejlesztéshez?
- [ ] A) React Native
- [ ] B) Flutter
- [ ] C) Xamarin
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>D) Mindhárom</b>
Mindhárom keretrendszer alkalmas hibrid mobilalkalmazások fejlesztésére.
</details>

## 3. Mit jelent a "responsive design"?
- [ ] A) Az alkalmazás gyors reagálását
- [ ] B) A felület automatikus alkalmazkodását különböző képernyőméretekhez
- [ ] C) A felhasználói interakciók kezelését
- [ ] D) Az alkalmazás offline működését

<details>
<summary>Megoldás</summary>
<b>B) A felület automatikus alkalmazkodását különböző képernyőméretekhez</b>
A responsive design biztosítja, hogy az alkalmazás jól jelenjen meg minden méretű készüléken.
</details>

## 4. Melyik NEM előnye a natív mobilalkalmazásoknak?
- [ ] A) Teljes hozzáférés az eszköz funkcióihoz
- [ ] B) Legjobb teljesítmény
- [ ] C) Egyszerre több platformon működik ugyanazzal a kóddal
- [ ] D) Legjobb felhasználói élmény

<details>
<summary>Megoldás</summary>
<b>C) Egyszerre több platformon működik ugyanazzal a kóddal</b>
A natív alkalmazások platform-specifikusak, külön kell fejleszteni iOS-re és Androidra.
</details>

## 5. Mi a Firebase fő használati területe mobilfejlesztésben?
- [ ] A) Backend szolgáltatások (adatbázis, hitelesítés)
- [ ] B) UI komponensek gyűjteménye
- [ ] C) Mobil eszközök gyártása
- [ ] D) Operációs rendszer fejlesztése

<details>
<summary>Megoldás</summary>
<b>A) Backend szolgáltatások (adatbázis, hitelesítés)</b>
A Firebase Google által fejlesztett backend szolgáltatásokat kínál mobilfejlesztőknek.
</details>

## 6. Melyik JavaScript keretrendszer alkalmas mobilalkalmazások fejlesztésére?
- [ ] A) Angular
- [ ] B) React Native
- [ ] C) Vue.js
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>B) React Native</b>
React Native-t kifejezetten mobilalkalmazások fejlesztésére tervezték, míg az Angular és Vue.js főleg webalkalmazásokhoz használatos.
</details>

## 7. Mi a célja az Android Studio-nak?
- [ ] A) Android alkalmazások fejlesztése
- [ ] B) iOS alkalmazások tesztelése
- [ ] C) Mobiljátékok tervezése
- [ ] D) Felhőszolgáltatások kezelése

<details>
<summary>Megoldás</summary>
<b>A) Android alkalmazások fejlesztése</b>
Az Android Studio a hivatalos fejlesztői környezet Android alkalmazások készítéséhez.
</details>

## 8. Melyik C# keretrendszer használható mobilalkalmazások fejlesztésére?
- [ ] A) .NET MAUI
- [ ] B) ASP.NET Core
- [ ] C) Entity Framework
- [ ] D) Windows Forms

<details>
<summary>Megoldás</summary>
<b>A) .NET MAUI</b>
A .NET MAUI (Multi-platform App UI) keretrendszer alkalmas mobil- és asztali alkalmazások fejlesztésére.
</details>

## 9. Mi a Progressive Web App (PWA) fő előnye?
- [ ] A) Nem igényel böngészőt
- [ ] B) Telepítés nélkül is használható
- [ ] C) Natív alkalmazásokhoz hasonló élményt nyújt
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>B) Telepítés nélkül is használható</b>
A PWA-k a böngészőből közvetlenül használhatók, bár néhány natív funkciót is támogatnak.
</details>

## 10. Melyik NEM fontos szempont mobilalkalmazások tervezésénél?
- [ ] A) Egyszerű és intuitív kezelhetőség
- [ ] B) Gyors betöltési idő
- [ ] C) Kis méret
- [ ] D) Sok animáció és vizuális effekt

<details>
<summary>Megoldás</summary>
<b>D) Sok animáció és vizuális effekt</b>
Túl sok animáció rontja a teljesítményt és növeli az alkalmazás méretét.
</details>
# Laravel REST API & ORM Tesztkérdések

## 1. Melyik parancs létrehoz egy új Laravel projektet?
- [ ] A) `laravel new project-name`
- [ ] B) `composer create-project laravel/laravel project-name`
- [ ] C) `php artisan new project-name`
- [ ] D) Mind A és B

<details>
<summary>Megoldás</summary>
<b>D) Mind A és B</b>
Mindkét parancs érvényes Laravel projekt létrehozására.
</details>

## 2. Melyik Artisan parancs generál új modellt és migrációs fájlt egyszerre?
- [ ] A) `php artisan make:model ModelName -mc`
- [ ] B) `php artisan create:model ModelName --migration`
- [ ] C) `php artisan generate:model ModelName --all`
- [ ] D) `php artisan model:create ModelName`

<details>
<summary>Megoldás</summary>
<b>A) `php artisan make:model ModelName -mc`</b>
A `-m` vagy `--migration` kapcsoló generál migrációs fájlt, a `-c` pedig kontrollert.
</details>

## 3. Hogyan definiálunk egy alap REST API útvonalat Laravel-ben?
- [ ] A) `Route::api('users', 'UserController');`
- [ ] B) `Route::resource('users', UserController::class);`
- [ ] C) `Route::rest('users', 'UserController');`
- [ ] D) `Route::apiResource('users', 'UserController');`

<details>
<summary>Megoldás</summary>
<b>B) `Route::resource('users', UserController::class);`</b>
Ez generálja az összes RESTful útvonalat (GET, POST, PUT/PATCH, DELETE).
</details>

## 4. Melyik metódus felel meg a `GET /api/users/{id}` kérésnek?
- [ ] A) `show()`
- [ ] B) `get()`
- [ ] C) `index()`
- [ ] D) `find()`

<details>
<summary>Megoldás</summary>
<b>A) `show()`</b>
A `show()` metódus kezeli az egyedi erőforrás megjelenítését.
</details>

## 5. Hogyan küldünk JSON választ Laravel API-ból?
- [ ] A) `return response()->json($data);`
- [ ] B) `return $data->toJson();`
- [ ] C) `echo json_encode($data);`
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>A) `return response()->json($data);`</b>
Ez a legtisztább módja JSON válasz küldésének Laravel-ben.
</details>

## 6. Melyik NEM beépített middleware a Laravel API fejlesztéshez?
- [ ] A) `auth:api`
- [ ] B) `throttle:api`
- [ ] C) `cors`
- [ ] D) `json.response`

<details>
<summary>Megoldás</summary>
<b>D) `json.response`</b>
Nincs ilyen beépített middleware, a CORS kezeléshez külön csomag szükséges.
</details>

## 7. Hogyan hozunk létre egy API erőforrás osztályt?
- [ ] A) `php artisan make:resource UserResource`
- [ ] B) `php artisan generate:resource UserResource`
- [ ] C) `php artisan resource:create UserResource`
- [ ] D) `php artisan make:api UserResource`

<details>
<summary>Megoldás</summary>
<b>A) `php artisan make:resource UserResource`</b>
Az API erőforrás osztályok az adatok JSON reprezentációját kezelik.
</details>

## 8. Melyik Eloquent metódus nem végzett adatbázis lekérdezést?
- [ ] A) `get()`
- [ ] B) `all()`
- [ ] C) `first()`
- [ ] D) `toSql()`

<details>
<summary>Megoldás</summary>
<b>D) `toSql()`</b>
A `toSql()` csak a SQL lekérdezést adja vissza stringként, nem hajtja végre.
</details>

## 9. Hogyan definiálunk egy "egy-a-többhöz" kapcsolatot Eloquent-ben?
- [ ] A) `hasOne()`
- [ ] B) `belongsTo()`
- [ ] C) `hasMany()`
- [ ] D) `manyToMany()`

<details>
<summary>Megoldás</summary>
<b>C) `hasMany()`</b>
Például egy User `hasMany()` Post kapcsolatot jelent.
</details>

## 10. Melyik NEM Eloquent model event?
- [ ] A) `creating`
- [ ] B) `saving`
- [ ] C) `updating`
- [ ] D) `rendering`

<details>
<summary>Megoldás</summary>
<b>D) `rendering`</b>
A `rendering` nem model event, hanem view event.
</details>

## 11. Milyen HTTP státuszkódot küldjünk sikeres létrehozáskor?
- [ ] A) 200 OK
- [ ] B) 201 Created
- [ ] C) 204 No Content
- [ ] D) 302 Found

<details>
<summary>Megoldás</summary>
<b>B) 201 Created</b>
A 201 a megfelelő válasz sikeres létrehozáskor, tartalmazhat Location headert.
</details>

## 12. Hogyan validálunk bejövő API kérést Laravel-ben?
- [ ] A) `$request->validate([...])`
- [ ] B) `Validator::make($request->all(), [...])`
- [ ] C) Mindkettő
- [ ] D) `$this->checkValidation($request)`

<details>
<summary>Megoldás</summary>
<b>C) Mindkettő</b>
Mindkét módszer érvényes, az első a kényelmesebb, a második több kontrollt ad.
</details>

## 13. Melyik csomag NEM szükséges alap Laravel API fejlesztéshez?
- [ ] A) `laravel/sanctum`
- [ ] B) `fruitcake/laravel-cors`
- [ ] C) `tymon/jwt-auth`
- [ ] D) `laravel/framework`

<details>
<summary>Megoldás</summary>
<b>C) `tymon/jwt-auth`</b>
A JWT hitelesítés nem része az alap Laravelnek, opcionális csomag.
</details>

## 14. Hogyan kérdezünk le adatokat kapcsolatokkal Eloquent-ben?
- [ ] A) `User::with('posts')->get()`
- [ ] B) `User::join('posts')->get()`
- [ ] C) `User::eagerLoad('posts')->get()`
- [ ] D) `User::include('posts')->get()`

<details>
<summary>Megoldás</summary>
<b>A) `User::with('posts')->get()`</b>
Az `with()` metódus eager loadingot végez, N+1 probléma elkerülésére.
</details>

## 15. Melyik NEM REST API elv?
- [ ] A) Állapotmentesség (Stateless)
- [ ] B) Egységes interfész
- [ ] C) Szerver-kezdeményezésű események
- [ ] D) Erőforrás alapú

<details>
<summary>Megoldás</summary>
<b>C) Szerver-kezdeményezésű események</b>
A REST alapvetően kliens-kezdeményezésű, nem támogat szerver push-t.
</details>

## 16. Hogyan csoportosítunk útvonalakat API prefixszel?
- [ ] A) `Route::group(['prefix' => 'api'], function() {...})`
- [ ] B) `Route::prefix('api')->group(function() {...})`
- [ ] C) Mindkettő
- [ ] D) `Route::api('prefix', 'api')`

<details>
<summary>Megoldás</summary>
<b>C) Mindkettő</b>
Mindkét szintaxis érvényes és használatos.
</details>

## 17. Melyik Eloquent metódus ment el egy modellt?
- [ ] A) `save()`
- [ ] B) `create()`
- [ ] C) `update()`
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>D) Mindhárom</b>
Mindhárom metódus elmenti a módosításokat, különböző használati módokkal.
</details>

## 18. Hogyan kezelünk tömeges hozzárendelést (mass assignment)?
- [ ] A) `$fillable` tulajdonság
- [ ] B) `$guarded` tulajdonság
- [ ] C) Mindkettő
- [ ] D) `$massAssign` tulajdonság

<details>
<summary>Megoldás</summary>
<b>C) Mindkettő</b>
A `$fillable` whitelistet, a `$guarded` blacklistet határoz meg.
</details>

## 19. Melyik NEM Laravel beépített kérés típus?
- [ ] A) `PUT`
- [ ] B) `PATCH`
- [ ] C) `MERGE`
- [ ] D) `DELETE`

<details>
<summary>Megoldás</summary>
<b>C) `MERGE`</b>
A MERGE nem standard HTTP metódus, a PATCH hasonló funkcionalitást nyújt.
</details>

## 20. Hogyan hozunk létre API hitelesítést Sanctummal?
- [ ] A) `php artisan sanctum:install`
- [ ] B) `composer require laravel/sanctum`
- [ ] C) Mindkettő
- [ ] D) `php artisan make:auth --api`

<details>
<summary>Megoldás</summary>
<b>C) Mindkettő</b>
Először telepíteni kell a csomagot, majd futtatni az install parancsot.
</details>

## 21. Melyik Artisan parancs generál új API erőforrás kontrollert?
- [ ] A) `php artisan make:controller Api/UserController`
- [ ] B) `php artisan make:controller UserController --api`
- [ ] C) `php artisan make:api-controller UserController`
- [ ] D) `php artisan generate:controller UserController --resource`

<details>
<summary>Megoldás</summary>
<b>B) `php artisan make:controller UserController --api`</b>
Az `--api` kapcsoló létrehoz egy API optimalizált erőforrás kontrollert.
</details>

## 22. Hogyan kezeljük a 404 hibát API válaszként?
- [ ] A) `abort(404)`
- [ ] B) `response()->json([], 404)`
- [ ] C) `throw new NotFoundHttpException`
- [ ] D) Mindhárom

<details>
<summary>Megoldás</summary>
<b>D) Mindhárom</b>
Mindhárom módszer érvényes, különböző használati esetekhez.
</details>

## 23. Melyik Laravel osztály felel az adatbázis kapcsolatért?
- [ ] A) `DB`
- [ ] B) `Eloquent`
- [ ] C) `Schema`
- [ ] D) `Connection`

<details>
<summary>Megoldás</summary>
<b>A) `DB`</b>
A `DB` facade biztosítja az alap adatbázis kapcsolatot és lekérdezéseket.
</details>

## 24. Hogyan hozunk létre egy form requestet API validációhoz?
- [ ] A) `php artisan make:request Api/UserRequest`
- [ ] B) `php artisan generate:request UserRequest`
- [ ] C) `php artisan request:create UserRequest`
- [ ] D) `php artisan make:form-request UserRequest`

<details>
<summary>Megoldás</summary>
<b>A) `php artisan make:request Api/UserRequest`</b>
A form requestek dedikált validációs osztályok komplexebb szabályokhoz.
</details>

## 25. Melyik NEM Eloquent kapcsolat típus?
- [ ] A) `hasOneThrough`
- [ ] B) `belongsToMany`
- [ ] C) `morphTo`
- [ ] D) `linksTo`

<details>
<summary>Megoldás</summary>
<b>D) `linksTo`</b>
Nincs ilyen kapcsolat típus Eloquent-ben, a többi valós kapcsolatot ír le.
</details>
# Frontend JavaScript Keretrendszerek és Vue.js Options API Tesztkérdések

## 1. Melyik NEM egy frontend JavaScript keretrendszer?
- [ ] A) React
- [ ] B) Angular
- [ ] C) Vue.js
- [ ] D) Django 

<details>
<summary>Megoldás</summary>
<b>D) Django</b>

Django egy backend Python keretrendszer, nem frontend JavaScript megoldás.
</details>

## 2. Mi a Vue.js fő jellemzője?
- [ ] A) Progresszív keretrendszer, komponens-alapú 
- [ ] B) Csak nagyvállalati projektekhez
- [ ] C) Kizárólag TypeScript-tel használható
- [ ] D) Nincs virtuális DOM-ja

<details>
<summary>Megoldás</summary>
<b>A) Progresszív keretrendszer, komponens-alapú</b>

A Vue.js fokozatosan bevezethető, és erős komponens-rendszere van.
</details>

## 3. Melyik Vue.js Options API tulajdonság tartalmazza a komponens adatait?
- [ ] A) methods
- [ ] B) computed
- [ ] C) data 
- [ ] D) watch

<details>
<summary>Megoldás</summary>
<b>C) data</b>

A data egy függvény, amely az adatobjektumot adja vissza.
</details>

## 4. Hogyan definiálunk egy metódust Vue Options API-ban?
```javascript
export default {
  ___: {
    handleClick() {
      console.log('Clicked!')
    }
  }


}
- [ ] A) functions
- [ ] B) methods 
- [ ] C) actions
- [ ] D) handlers

<details> <summary>Megoldás</summary> <b>B) methods</b>
A metódusok a methods objektumban kerülnek definiálásra.

</details>

## 5. Mi lesz a kimenet?

```javascript
export default {
  data() {
    return {
      count: 0
    }
  },
  created() {
    this.count = 5
  }
}
// Template: <div>{{ count }}</div>
```

- [ ] A) 0
- [ ] B) 5 
- [ ] C) undefined
- [ ] D) Hiba

<details> 
<summary>Megoldás</summary> <b>B) 5</b>
A created() lifecycle hook a komponens létrehozásakor fut, még a renderelés előtt.

</details>

## 6. Melyik Vue lifecycle hook fut legelőször?

- [ ] A) beforeCreate 
- [ ] B) created
- [ ] C) beforeMount
- [ ] D) mounted

<details> 

<summary>Megoldás</summary> <b>A) beforeCreate</b>
A lifecycle sorrend: beforeCreate → created → beforeMount → mounted.

</details>

## 7. Hogyan kell definiálni egy számított property-t?

```javascript
export default {
  data() {
    return { firstName: 'John', lastName: 'Doe' }
  },
  ___: {
    fullName() {
      return `${this.firstName} ${this.lastName}`
    }
  }
}
```

- [ ] A) computed 
- [ ] B) methods
- [ ] C) watchers
- [ ] D) properties

<details> 

<summary>Megoldás</summary> <b>
A) computed</b>
A számított property-k a computed objektumban kerülnek definiálásra, és cache-elődnek.

</details>

## 8. Mi a különbség a v-if és v-show között?

- [ ] A) A v-if eltávolítja a DOM-ból, a v-show csak elrejti 
- [ ] B) A v-show gyorsabb változáskor
- [ ] C) A v-if csak komponenseken működik
- [ ] D) Nincs különbség

<details> <summary>Megoldás</summary> <b>A) A v-if eltávolítja a DOM-ból, a v-show csak elrejti</b>
A v-if teljesen eltávolítja/megjeleníti az elemet, a v-show CSS display tulajdonságot használ.

</details>

## 9. Hogyan lehet props-ot definiálni egy komponensben?

```javascript
export default {
  ___: {
    userName: {
      type: String,
      required: true
    }
  }
}
```

- [ ] A) parameters
- [ ] B) props 
- [ ] C) attributes
- [ ] D) inputs

<details> <summary>Megoldás</summary> <b>B) props</b>
A props objektumban definiáljuk a komponens által fogadott tulajdonságokat.

</details>

## 10. Mire szolgál a v-model direktíva?

- [ ] A) Kétirányú adatkötés létrehozására 
- [ ] B) CSS osztályok dinamikus kezelésére
- [ ] C) Eseménykezelésre
- [ ] D) Feltételes renderelésre

<details> <summary>Megoldás</summary> <b>A) Kétirányú adatkötés létrehozására</b>
A v-model egyszerűsíti a form elemek és a komponens adatainak szinkronizálását.

</details>

## 11. Hogyan lehet watch-olni egy adatváltozást?

```javascript
export default {
  data() {
    return { count: 0 }
  },
  ___: {
    count(newVal, oldVal) {
      console.log(`Changed from ${oldVal} to ${newVal}`)
    }
  }
}
```
- [ ] A) observers
- [ ] B) watchers
- [ ] C) watch 
- [ ] D) onChange

<details> <summary>Megoldás</summary> <b>C) watch</b>
A watch objektumban definiálhatunk figyelő függvényeket adatváltozásokra.

</details>

## 12. Melyik direktíva listaelemek renderelésére szolgál?

- [ ] A) v-for 
- [ ] B) v-repeat
- [ ] C) v-list
- [ ] D) v-foreach

<details> <summary>Megoldás</summary> <b>A) v-for</b>
Példa: 

`<li v-for="item in items" :key="item.id">{{ item.text }}</li>`

</details>

## 13. Mi a Vue Router fő feladata?

- [ ] A) Állapotkezelés
- [ ] B) Kliensoldali útválasztás kezelése 
- [ ] C) HTTP kérések kezelése
- [ ] D) Form validáció

<details> <summary>Megoldás</summary> <b>B) Kliensoldali útválasztás kezelése</b>
A Vue Router SPA-k (Single Page Application) útválasztását kezeli.

</details>

## 14. Hogyan lehet globális komponenst regisztrálni?

```javascript
Vue.___('my-component', { /* options */ })
```

- [ ] A) registerComponent
- [ ] B) component 
- [ ] C) addComponent
- [ ] D) newComponent

<details> <summary>Megoldás</summary> <b>B) component</b>
Globális komponensek a Vue.component() metódussal regisztrálhatók.

</details>

## 15. Mire szolgál a $emit metódus?

- [ ] A) Szülő komponensnek küld eseményt 
- [ ] B) HTTP kérést küld
- [ ] C) Konzolra ír
- [ ] D) Vuex store-t módosít

<details> <summary>Megoldás</summary> <b>A) Szülő komponensnek küld eseményt</b>
Gyermek komponensből lehet eseményeket küldeni a szülőnek: this.$emit('event-name', data)

</details>

## 16. Hogyan kell használni a slot-ot?

```html
<!-- Child Component -->
<div>
  <___></___>
</div>

<!-- Parent Component -->
<child-component>
  <p>This will appear in the slot</p>
</child-component>
```

- [ ] A) `<content>`
- [ ] B)` <slot> `
- [ ] C) `<children>`
- [ ] D) `<template>`

<details> <summary>Megoldás</summary> 
B
A slot lehetővé teszi tartalom projektálást a komponensekbe.

</details>

## 17. Melyik NEM egy Vue.js verzió?

- [ ] A) Vue 1.x
- [ ] B) Vue 2.x
- [ ] C) Vue 3.x
- [ ] D) Vue 4.x 

<details> <summary>Megoldás</summary> <b>D) Vue 4.x</b>
2023-ban a legfrissebb stabil verzió a Vue 3.x.

</details>

## 18. Mi a Vuex szerepe?

- [ ] A) Központosított állapotkezelés 
- [ ] B) Komponens létrehozás
- [ ] C) Form validáció
- [ ] D) HTTP kérések kezelése

<details> <summary>Megoldás</summary> <b>A) Központosított állapotkezelés</b>
A Vuex a Vue.js állapotkezelő könyvtára nagyobb alkalmazásokhoz.

</details>

## 19. Hogyan lehet dinamikusan osztályt hozzáadni?

```html
<div ___="{ active: isActive }"></div>
```
- [ ] A) v-class
- [ ] B) :class 
- [ ] C) @class
- [ ] D) bind-class

<details> <summary>Megoldás</summary> <b>B) :class</b>
A :class (v-bind:class rövidítése) lehetővé teszi dinamikus osztályok kötését.

</details>

## 20. Mi a Composition API fő előnye az Options API-hoz képest?

- [ ] A) Jobban hasonlít a React hookokhoz
- [ ] B) Logikai funkciók jobb újrafelhasználhatósága 
- [ ] C) Könnyebb tanulni
- [ ] D) Kisebb bundle méret

<details> <summary>Megoldás</summary> <b>B) Logikai funkciók jobb újrafelhasználhatósága</b>
A Composition API lehetővé teszi a logika függvényekbe szervezését és újrafelhasználását.

</details> 
# CMS Alapok - Bevezető Kérdések

## 1. Mit jelent a CMS rövidítés?
- [ ] A) Content Management Software
- [ ] B) Central Media System
- [ ] C) Content Management System
- [ ] D) Creative Media Solution

<details>
<summary>Megoldás</summary>
<b>C) Content Management System</b>
A CMS egy olyan szoftver, amely segít a digitális tartalmak létrehozásában, kezelésében és módosításában.
</details>

## 2. Melyik NEM tipikus CMS funkció?
- [ ] A) Tartalom szerkesztése
- [ ] B) Felhasználókezelés
- [ ] C) Adatbázis programozása
- [ ] D) Képfeltöltés

<details>
<summary>Megoldás</summary>
<b>C) Adatbázis programozása</b>
A CMS-ek általában nem igénylik adatbázis programozási ismereteket a használatukhoz.
</details>

## 3. Melyik a legnépszerűbb nyílt forráskódú CMS?
- [ ] A) WordPress
- [ ] B) Joomla
- [ ] C) Drupal
- [ ] D) Shopify

<details>
<summary>Megoldás</summary>
<b>A) WordPress</b>
A WordPress a világ legnépszerűbb CMS rendszere, az összes weboldal mintegy 40%-án fut.
</details>

## 4. Mit nevezünk "plugin"-nek CMS környezetben?
- [ ] A) Egy főbb CMS frissítés
- [ ] B) Kiegészítő funkcionalitást biztosító modul
- [ ] C) A CMS alapértelmezett témája
- [ ] D) Egy típusú adatbázis kapcsolat

<details>
<summary>Megoldás</summary>
<b>B) Kiegészítő funkcionalitást biztosító modul</b>
A plugin-ek bővítik a CMS alapfunkcióit új képességekkel.
</details>

## 5. Mi az a "WYSIWYG" szerkesztő?
- [ ] A) What You See Is What You Get - Pontosan azt látod, amit kapsz
- [ ] B) Web Yield System In Widget Graphics
- [ ] C) A CMS admin felületének neve
- [ ] D) Egy speciális programozási nyelv

<details>
<summary>Megoldás</summary>
<b>A) What You See Is What You Get - Pontosan azt látod, amit kapsz</b>
Egy vizuális szerkesztő, ahol a megjelenés megegyezik a végeredménnyel.
</details>

## 6. Melyik NEM CMS típus?
- [ ] A) Önálló CMS (pl. WordPress)
- [ ] B) Fejlődő CMS (Progressive CMS)
- [ ] C) Fej nélküli CMS (Headless CMS)
- [ ] D) SaaS alapú CMS (pl. Wix)

<details>
<summary>Megoldás</summary>
<b>B) Fejlődő CMS (Progressive CMS)</b>
Nincs ilyen kifejezett CMS kategória, a többi valós típus.
</details>

## 7. Mi a "téma" szerepe egy CMS-ben?
- [ ] A) Meghatározza a weboldal vizuális megjelenését
- [ ] B) Az admin felület jelszavas védelme
- [ ] C) A tartalom adatbázis szerkezete
- [ ] D) A szerver konfigurációs fájlja

<details>
<summary>Megoldás</summary>
<b>A) Meghatározza a weboldal vizuális megjelenését</b>
A témák szabják meg a weboldal kinézetét és felépítését.
</details>

## 8. Melyik előnye a CMS-ek használatának?
- [ ] A) Nem igényel technikai ismereteket
- [ ] B) Teljesen ingyenes minden esetben
- [ ] C) Nem szükséges tartalmat létrehozni
- [ ] D) Könnyű tartalomkezelés minimális technikai tudással

<details>
<summary>Megoldás</summary>
<b>D) Könnyű tartalomkezelés minimális technikai tudással</b>
A CMS-ek épp azért népszerűek, mert egyszerűvé teszik a tartalomkezelést.
</details>

## 9. Mi az a "headless CMS"?
- [ ] A) CMS admin felület nélkül
- [ ] B) Olyan CMS, ami csak a tartalmat kezeli, a megjelenítés más rendszerre hagyatkozik
- [ ] C) Egy elavult CMS típus
- [ ] D) Mobilalkalmazásokhoz készült CMS

<details>
<summary>Megoldás</summary>
<b>B) Olyan CMS, ami csak a tartalmat kezeli, a megjelenítés más rendszerre hagyatkozik</b>
A headless CMS csak a tartalmat szolgáltatja API-n keresztül, külön választva a backendet a frontendtől.
</details>

## 10. Melyik NEM nyílt forráskódú CMS?
- [ ] A) WordPress
- [ ] B) Shopify
- [ ] C) Joomla
- [ ] D) Drupal

<details>
<summary>Megoldás</summary>
<b>B) Shopify</b>
A Shopify egy kereskedelmi, SaaS alapú e-commerce platform, nem nyílt forráskódú.
</details>

# Objektum Orientált Programozás (OOP) Tesztkérdések

## 1. Mi az OOP alapvető célja?
- [ ] A) Procedurális kód írása
- [ ] B) Adatok és viselkedés egy egységbe zárása 
- [ ] C) Kizárólag matematikai műveletek
- [ ] D) Alacsony szintű memóriakezelés

<details>
<summary>Megoldás</summary>
<b>B) Adatok és viselkedés egy egységbe zárása</b>

Az OOP fő célja, hogy az adatokat és a hozzájuk tartozó műveleteket objektumokba csomagolja.
</details>

## 2. Melyik NEM az OOP alapelve?
- [ ] A) Egységbezárás
- [ ] B) Öröklődés
- [ ] C) Polimorfizmus
- [ ] D) Lineáris végrehajtás 

<details>
<summary>Megoldás</summary>
<b>D) Lineáris végrehajtás</b>

Az OOP négy alapelve: egységbezárás, öröklődés, polimorfizmus, absztrakció.
</details>

## 3. Mit jelent az egységbezárás (encapsulation)?
- [ ] A) Adatok elrejtése és védelme 
- [ ] B) Osztályok másolása
- [ ] C) Kód optimalizálása
- [ ] D) Függvények láncolása

<details>
<summary>Megoldás</summary>
<b>A) Adatok elrejtése és védelme</b>

Az egységbezárás azt jelenti, hogy az objektum belső állapotát csak meghatározott módon lehet megváltoztatni.
</details>

## 4. Mi az osztály és az objektum kapcsolata?
- [ ] A) Az osztály az objektum példánya
- [ ] B) Az objektum az osztály példánya 
- [ ] C) Teljesen független fogalmak
- [ ] D) Azonos fogalmak

<details>
<summary>Megoldás</summary>
<b>B) Az objektum az osztály példánya</b>

Az osztály egy tervrajz, az objektum pedig a tervrajz alapján létrehozott konkrét példány.
</details>

## 5. Mit jelent az öröklődés (inheritance)?
- [ ] A) Metódusok átnevezése
- [ ] B) Új osztály létrehozása meglévő osztály alapján 
- [ ] C) Kód újrafelhasználásának tiltása
- [ ] D) Adatok törlése

<details>
<summary>Megoldás</summary>
<b>B) Új osztály létrehozása meglévő osztály alapján</b>

Az öröklődés lehetővé teszi, hogy egy osztály megörökölje egy másik osztály tulajdonságait és metódusait.
</details>

## 6. Mi a polimorfizmus lényege?
- [ ] A) Azonos interfész, különböző implementáció 
- [ ] B) Osztályok másolása
- [ ] C) Kizárólag matematikai műveletek
- [ ] D) Kód duplikálása

<details>
<summary>Megoldás</summary>
<b>A) Azonos interfész, különböző implementáció</b>

A polimorfizmus azt jelenti, hogy különböző osztályok ugyanazt a metódust különbözőképpen implementálhatják.
</details>

## 7. Mit jelent az absztrakció?
- [ ] A] Komplexitás csökkentése lényeges jellemzők kiemelésével 
- [ ] B] Minden részlet pontos megjelenítése
- [ ] C] Kód minőségének mérése
- [ ] D] Változók típusának elrejtése

<details>
<summary>Megoldás</summary>
<b>A) Komplexitás csökkentése lényeges jellemzők kiemelésével</b>

Az absztrakció a felesleges részletek elrejtésével és a lényeges funkciók kiemelésével működik.
</details>

## 8. Mi a konstruktor szerepe?
- [ ] A) Objektum inicializálása 
- [ ] B) Memória felszabadítása
- [ ] C) Osztály törlése
- [ ] D) Adatok titkosítása

<details>
<summary>Megoldás</summary>
<b>A) Objektum inicializálása</b>

A konstruktor speciális metódus, amely az objektum létrehozásakor fut le és inicializálja azt.
</details>

## 9. Mi a különbség az interfész és az absztrakt osztály között?
- [ ] A) Az interfész csak metódusokat deklarál, az absztrakt osztály implementálhat is 
- [ ] B) Az absztrakt osztály csak statikus metódusokat tartalmazhat
- [ ] C) Az interfész nem használható polimorfizmusra
- [ ] D) Nincs lényegi különbség

<details>
<summary>Megoldás</summary>
<b>A) Az interfész csak metódusokat deklarál, az absztrakt osztály implementálhat is</b>

Az interfész csak szerződést definiál, míg az absztrakt osztály részleges implementációt is tartalmazhat.
</details>

## 10. Mit jelent a "has-a" kapcsolat?
- [ ] A] Öröklődési viszony
- [ ] B] Kompozíció vagy aggregáció 
- [ ] C] Polimorfikus viselkedés
- [ ] D] Statikus kapcsolat

<details>
<summary>Megoldás</summary>
<b>B) Kompozíció vagy aggregáció</b>

A "has-a" kapcsolat azt jelenti, hogy egy osztály tartalmaz egy másik osztály példányát.
</details>

## 11. Melyik NEM egy hozzáférésmódosító?
- [ ] A) public
- [ ] B) private
- [ ] C) protected
- [ ] D) static 

<details>
<summary>Megoldás</summary>
<b>D) static</b>

A static nem hozzáférésmódosító, hanem azt jelzi, hogy az adott tag osztályszintű.
</details>

## 12. Mi a metódus túlterhelés (overloading)?
- [ ] A) Azonos névvel, de különböző paraméterlistával rendelkező metódusok 
- [ ] B) Metódusok elrejtése
- [ ] C) Metódusok törlése
- [ ] D) Metódusok átnevezése

<details>
<summary>Megoldás</summary>
<b>A) Azonos névvel, de különböző paraméterlistával rendelkező metódusok</b>

A túlterhelés lehetővé teszi, hogy egy metódusnév alatt különböző paraméterlistákkal rendelkező metódusokat hozzunk létre.
</details>

## 13. Mit jelent a metódus felülírás (overriding)?
- [ ] A) Szülőosztály metódusának újradefiniálása gyermekosztályban 
- [ ] B] Metódus paramétereinek módosítása
- [ ] C] Metódus törlése
- [ ] D] Metódus más osztályba helyezése

<details>
<summary>Megoldás</summary>
<b>A) Szülőosztály metódusának újradefiniálása gyermekosztályban</b>

A gyermekosztály felülírhatja a szülőosztály metódusait, hogy saját implementációt adjon.
</details>

## 14. Mi a SOLID elv?
- [ ] A) OOP tervezési alapelvek gyűjteménye 
- [ ] B) Adatbázis normalizálási szabály
- [ ] C) Kódolási konvenció
- [ ] D) Programozási nyelv

<details>
<summary>Megoldás</summary>
<b>A) OOP tervezési alapelvek gyűjteménye</b>

SOLID: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.
</details>

## 15. Mit jelent a "Single Responsibility Principle"?
- [ ] A) Minden osztálynak egyetlen felelősséget kell vállalnia 
- [ ] B) Minden metódusnak egy műveletet kell végeznie
- [ ] C) Minden változónak egy értéke lehet
- [ ] D) Minden programnak egy fő funkciója legyen

<details>
<summary>Megoldás</summary>
<b>A) Minden osztálynak egyetlen felelősséget kell vállalnia</b>

Egy osztály csak egy okból kelljen változzon, csak egy szerepkörrel rendelkezzen.
</details>

## 16. Mit jelent a "Liskov Substitution Principle"?
- [ ] A] Gyermekosztályok helyettesíthetők legyenek szülőosztályaikkal 
- [ ] B] Minden osztálynak legyen konstruktora
- [ ] C] Metódusok ne változtassák meg paramétereiket
- [ ] D] Osztályok ne örököljenek egymástól

<details>
<summary>Megoldás</summary>
<b>A) Gyermekosztályok helyettesíthetők legyenek szülőosztályaikkal</b>

A gyermekosztályok ne szegjék meg a szülőosztály viselkedését.
</details>

## 17. Mi a "Dependency Inversion Principle"?
- [ ] A] Magas szintű modulok ne függjenek alacsony szintű moduloktól 
- [ ] B] Minden függőséget el kell távolítani
- [ ] C] Osztályok ne használjanak interfészeket
- [ ] D] Csak konkrét implementációkra lehet hivatkozni

<details>
<summary>Megoldás</summary>
<b>A) Magas szintű modulok ne függjenek alacsony szintű moduloktól</b>

Mindkettőnek absztrakcióktól kell függenie, ne konkrét implementációktól.
</details>

## 18. Mit jelent a "tell, don't ask" elv?
- [ ] A] Objektumoknak parancsoljunk, ne kérdezzük állapotukat 
- [ ] B] Mindig kérdezzük meg az objektum állapotát
- [ ] C] Ne kommunikáljunk az objektumokkal
- [ ] D] Csak statikus metódusokat használjunk

<details>
<summary>Megoldás</summary>
<b>A) Objektumoknak parancsoljunk, ne kérdezzük állapotukat</b>

Az objektum maga döntse el, mit csináljon a saját állapotával, ne külső kód.
</details>

## 19. Mi a "Law of Demeter"?
- [ ] A] Objektum csak közvetlen ismerőseivel kommunikáljon 
- [ ] B] Minden osztálynak legyen dokumentációja
- [ ] C] Metódusok ne legyenek hosszabbak 10 sornál
- [ ] D] Ne használjunk privát változókat

<details>
<summary>Megoldás</summary>
<b>A) Objektum csak közvetlen ismerőseivel kommunikáljon</b>

"Ne beszélj idegenekkel" elv - csökkenti az osztályok közötti függőséget.
</details>

## 20. Mi az "anti-pattern" az OOP-ben?
- [ ] A] Gyakori, de rossz tervezési megoldás 
- [ ] B] OOP elvek szigorú betartása
- [ ] C] Kód kommentelésének hiánya
- [ ] D] Túl sok interfész használata

<details>
<summary>Megoldás</summary>
<b>A) Gyakori, de rossz tervezési megoldás</b>

Anti-pattern példák: God Object, Spaghetti Code, Poltergeist.
</details>
